-- MySQL dump 10.13  Distrib 5.7.27, for Linux (x86_64)
--
-- Host: localhost    Database: blog
-- ------------------------------------------------------
-- Server version	5.7.27

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `accounts_bloguser`
--

DROP TABLE IF EXISTS `accounts_bloguser`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `accounts_bloguser` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `password` varchar(128) NOT NULL,
  `last_login` datetime(6) DEFAULT NULL,
  `is_superuser` tinyint(1) NOT NULL,
  `username` varchar(150) NOT NULL,
  `first_name` varchar(30) NOT NULL,
  `last_name` varchar(150) NOT NULL,
  `email` varchar(254) NOT NULL,
  `is_staff` tinyint(1) NOT NULL,
  `is_active` tinyint(1) NOT NULL,
  `date_joined` datetime(6) NOT NULL,
  `nickname` varchar(100) NOT NULL,
  `created_time` datetime(6) NOT NULL,
  `last_mod_time` datetime(6) NOT NULL,
  `source` varchar(100) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `username` (`username`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `accounts_bloguser`
--

LOCK TABLES `accounts_bloguser` WRITE;
/*!40000 ALTER TABLE `accounts_bloguser` DISABLE KEYS */;
INSERT INTO `accounts_bloguser` VALUES (1,'pbkdf2_sha256$150000$2mqu8nh0Hvpb$VNAP6q1IePFiqluWPy6URMP9SIm8P1MISrVXrB2lGvk=','2019-10-13 22:58:05.544360',1,'admin','','','252301699@qq.com',1,1,'2019-08-13 03:38:10.519667','','2019-08-13 03:38:10.519675','2019-08-13 03:38:10.519677',''),(2,'pbkdf2_sha256$150000$UuqLDaxnJeTG$7GnhTHfJqT7m2xbADcdK4uJnvmaIPK6rpZk4ZSR6N00=',NULL,1,'wzc','','','862752581@qq.com',0,0,'2019-08-13 03:42:41.000000','','2019-08-13 03:42:41.696975','2019-08-13 03:42:41.696976',''),(3,'pbkdf2_sha256$150000$pOPJ5yYRBw33$zxOdZwSFA0ZHke2fck/d5eOQ94zOuQrQ4QEe01zDD6Y=',NULL,0,'chenguolong','','','1203707239@qq.com',0,0,'2019-09-24 01:29:08.238580','','2019-09-24 01:29:08.238590','2019-09-24 01:29:08.238591','Register');
/*!40000 ALTER TABLE `accounts_bloguser` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `accounts_bloguser_groups`
--

DROP TABLE IF EXISTS `accounts_bloguser_groups`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `accounts_bloguser_groups` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `bloguser_id` int(11) NOT NULL,
  `group_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `accounts_bloguser_groups_bloguser_id_group_id_fc37e89b_uniq` (`bloguser_id`,`group_id`),
  KEY `accounts_bloguser_groups_group_id_98d76804_fk_auth_group_id` (`group_id`),
  CONSTRAINT `accounts_bloguser_gr_bloguser_id_a16ccbb7_fk_accounts_` FOREIGN KEY (`bloguser_id`) REFERENCES `accounts_bloguser` (`id`),
  CONSTRAINT `accounts_bloguser_groups_group_id_98d76804_fk_auth_group_id` FOREIGN KEY (`group_id`) REFERENCES `auth_group` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `accounts_bloguser_groups`
--

LOCK TABLES `accounts_bloguser_groups` WRITE;
/*!40000 ALTER TABLE `accounts_bloguser_groups` DISABLE KEYS */;
/*!40000 ALTER TABLE `accounts_bloguser_groups` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `accounts_bloguser_user_permissions`
--

DROP TABLE IF EXISTS `accounts_bloguser_user_permissions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `accounts_bloguser_user_permissions` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `bloguser_id` int(11) NOT NULL,
  `permission_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `accounts_bloguser_user_p_bloguser_id_permission_i_14808777_uniq` (`bloguser_id`,`permission_id`),
  KEY `accounts_bloguser_us_permission_id_ae5159b9_fk_auth_perm` (`permission_id`),
  CONSTRAINT `accounts_bloguser_us_bloguser_id_7e1b5742_fk_accounts_` FOREIGN KEY (`bloguser_id`) REFERENCES `accounts_bloguser` (`id`),
  CONSTRAINT `accounts_bloguser_us_permission_id_ae5159b9_fk_auth_perm` FOREIGN KEY (`permission_id`) REFERENCES `auth_permission` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `accounts_bloguser_user_permissions`
--

LOCK TABLES `accounts_bloguser_user_permissions` WRITE;
/*!40000 ALTER TABLE `accounts_bloguser_user_permissions` DISABLE KEYS */;
/*!40000 ALTER TABLE `accounts_bloguser_user_permissions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_group`
--

DROP TABLE IF EXISTS `auth_group`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_group` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(150) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_group`
--

LOCK TABLES `auth_group` WRITE;
/*!40000 ALTER TABLE `auth_group` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_group` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_group_permissions`
--

DROP TABLE IF EXISTS `auth_group_permissions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_group_permissions` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `group_id` int(11) NOT NULL,
  `permission_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `auth_group_permissions_group_id_permission_id_0cd325b0_uniq` (`group_id`,`permission_id`),
  KEY `auth_group_permissio_permission_id_84c5c92e_fk_auth_perm` (`permission_id`),
  CONSTRAINT `auth_group_permissio_permission_id_84c5c92e_fk_auth_perm` FOREIGN KEY (`permission_id`) REFERENCES `auth_permission` (`id`),
  CONSTRAINT `auth_group_permissions_group_id_b120cbf9_fk_auth_group_id` FOREIGN KEY (`group_id`) REFERENCES `auth_group` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_group_permissions`
--

LOCK TABLES `auth_group_permissions` WRITE;
/*!40000 ALTER TABLE `auth_group_permissions` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_group_permissions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_permission`
--

DROP TABLE IF EXISTS `auth_permission`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_permission` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `content_type_id` int(11) NOT NULL,
  `codename` varchar(100) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `auth_permission_content_type_id_codename_01ab375a_uniq` (`content_type_id`,`codename`),
  CONSTRAINT `auth_permission_content_type_id_2f476e4b_fk_django_co` FOREIGN KEY (`content_type_id`) REFERENCES `django_content_type` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=77 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_permission`
--

LOCK TABLES `auth_permission` WRITE;
/*!40000 ALTER TABLE `auth_permission` DISABLE KEYS */;
INSERT INTO `auth_permission` VALUES (1,'Can add log entry',1,'add_logentry'),(2,'Can change log entry',1,'change_logentry'),(3,'Can delete log entry',1,'delete_logentry'),(4,'Can view log entry',1,'view_logentry'),(5,'Can add permission',2,'add_permission'),(6,'Can change permission',2,'change_permission'),(7,'Can delete permission',2,'delete_permission'),(8,'Can view permission',2,'view_permission'),(9,'Can add group',3,'add_group'),(10,'Can change group',3,'change_group'),(11,'Can delete group',3,'delete_group'),(12,'Can view group',3,'view_group'),(13,'Can add content type',4,'add_contenttype'),(14,'Can change content type',4,'change_contenttype'),(15,'Can delete content type',4,'delete_contenttype'),(16,'Can view content type',4,'view_contenttype'),(17,'Can add session',5,'add_session'),(18,'Can change session',5,'change_session'),(19,'Can delete session',5,'delete_session'),(20,'Can view session',5,'view_session'),(21,'Can add site',6,'add_site'),(22,'Can change site',6,'change_site'),(23,'Can delete site',6,'delete_site'),(24,'Can view site',6,'view_site'),(25,'Can add 网站配置',7,'add_blogsettings'),(26,'Can change 网站配置',7,'change_blogsettings'),(27,'Can delete 网站配置',7,'delete_blogsettings'),(28,'Can view 网站配置',7,'view_blogsettings'),(29,'Can add 友情链接',8,'add_links'),(30,'Can change 友情链接',8,'change_links'),(31,'Can delete 友情链接',8,'delete_links'),(32,'Can view 友情链接',8,'view_links'),(33,'Can add 侧边栏',9,'add_sidebar'),(34,'Can change 侧边栏',9,'change_sidebar'),(35,'Can delete 侧边栏',9,'delete_sidebar'),(36,'Can view 侧边栏',9,'view_sidebar'),(37,'Can add 标签',10,'add_tag'),(38,'Can change 标签',10,'change_tag'),(39,'Can delete 标签',10,'delete_tag'),(40,'Can view 标签',10,'view_tag'),(41,'Can add 分类',11,'add_category'),(42,'Can change 分类',11,'change_category'),(43,'Can delete 分类',11,'delete_category'),(44,'Can view 分类',11,'view_category'),(45,'Can add 文章',12,'add_article'),(46,'Can change 文章',12,'change_article'),(47,'Can delete 文章',12,'delete_article'),(48,'Can view 文章',12,'view_article'),(49,'Can add 用户',13,'add_bloguser'),(50,'Can change 用户',13,'change_bloguser'),(51,'Can delete 用户',13,'delete_bloguser'),(52,'Can view 用户',13,'view_bloguser'),(53,'Can add 评论',14,'add_comment'),(54,'Can change 评论',14,'change_comment'),(55,'Can delete 评论',14,'delete_comment'),(56,'Can view 评论',14,'view_comment'),(57,'Can add oauth配置',15,'add_oauthconfig'),(58,'Can change oauth配置',15,'change_oauthconfig'),(59,'Can delete oauth配置',15,'delete_oauthconfig'),(60,'Can view oauth配置',15,'view_oauthconfig'),(61,'Can add oauth用户',16,'add_oauthuser'),(62,'Can change oauth用户',16,'change_oauthuser'),(63,'Can delete oauth用户',16,'delete_oauthuser'),(64,'Can view oauth用户',16,'view_oauthuser'),(65,'Can add 命令',17,'add_commands'),(66,'Can change 命令',17,'change_commands'),(67,'Can delete 命令',17,'delete_commands'),(68,'Can view 命令',17,'view_commands'),(69,'Can add 邮件发送log',18,'add_emailsendlog'),(70,'Can change 邮件发送log',18,'change_emailsendlog'),(71,'Can delete 邮件发送log',18,'delete_emailsendlog'),(72,'Can view 邮件发送log',18,'view_emailsendlog'),(73,'Can add OwnTrackLogs',19,'add_owntracklog'),(74,'Can change OwnTrackLogs',19,'change_owntracklog'),(75,'Can delete OwnTrackLogs',19,'delete_owntracklog'),(76,'Can view OwnTrackLogs',19,'view_owntracklog');
/*!40000 ALTER TABLE `auth_permission` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_article`
--

DROP TABLE IF EXISTS `blog_article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `created_time` datetime(6) NOT NULL,
  `last_mod_time` datetime(6) NOT NULL,
  `title` varchar(200) NOT NULL,
  `body` longtext NOT NULL,
  `pub_time` datetime(6) NOT NULL,
  `status` varchar(1) NOT NULL,
  `comment_status` varchar(1) NOT NULL,
  `type` varchar(1) NOT NULL,
  `views` int(10) unsigned NOT NULL,
  `article_order` int(11) NOT NULL,
  `author_id` int(11) NOT NULL,
  `category_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `title` (`title`),
  KEY `blog_article_author_id_905add38_fk_accounts_bloguser_id` (`author_id`),
  KEY `blog_article_category_id_7e38f15e_fk_blog_category_id` (`category_id`),
  CONSTRAINT `blog_article_author_id_905add38_fk_accounts_bloguser_id` FOREIGN KEY (`author_id`) REFERENCES `accounts_bloguser` (`id`),
  CONSTRAINT `blog_article_category_id_7e38f15e_fk_blog_category_id` FOREIGN KEY (`category_id`) REFERENCES `blog_category` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=64 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_article`
--

LOCK TABLES `blog_article` WRITE;
/*!40000 ALTER TABLE `blog_article` DISABLE KEYS */;
INSERT INTO `blog_article` VALUES (1,'2019-08-13 04:14:29.768820','2019-08-13 04:14:29.768827','Hello world','# Hello world\r\n\r\n## 哈哈哈\r\n刚部署完，算是上线了吧:cl: :feelsgood: :pouting_cat:\r\n\r\n## why do this\r\n之前写过很多版本的博客网站，后端有java的，php的，nodejs的， python的，前端有用过bootstrap、iview、elementui....\r\n发现每次做一版出来，过段时间又想换了,还用过纯静态的像gitbook、vuepress。\r\n但是总感觉哪里做的不够好。由于近期做了一个django的项目，并且很喜欢python。所以一直想搞一个django版本出来，这个项目是直接在github上找的.\r\n原作者的链接：[github地址](http://https://github.com/liangliangyy/DjangoBlog \"github地址\")\r\n在这个项目基础上添加了docker的开发环境，现部署在阿里云上。感谢作者。感谢开源。\r\n\r\n## 后续\r\n- 用这个博客记录一些学习过程和总结，能用自己的话讲出来才是自己的知识。实在是讲不出来，就直接贴网址了。。。。\r\n- 在这个项目的基础上，加上一些自己觉得需要的功能\r\n- 再次感谢作者\r\n\r\n- :pig2:','2019-08-13 03:57:27.000000','p','o','a',371,0,1,1),(2,'2019-08-13 06:23:17.349798','2019-08-13 06:23:17.349805','docker集成django项目开发环境的过程','# docker集成django项目的开发环境\r\n\r\n## 环境\r\n就不啰嗦为什么要用docker了，我也讲不来这些\r\n- Docker version 19.03.1, build 74b1e89\r\n- docker-compose version 1.24.1, build 4667896b\r\n- 宿主机：win10 64位\r\n- 服务器：Linux version 3.10.0-957.5.1.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC) ) #1 SMP Fri Feb 1 14:54:57 UTC 2019\r\n- 服务器是三年800块的1G\\1M\\1核的最低配置\r\n- 编辑器:pycharm\r\n- ssh工具：putty\r\n安装就百度了，安装一个软件看检查一下是否安装成功\r\n\r\n## 代码\r\n\r\n### Dockerfile\r\n```docker\r\nFROM python:3.6\r\nENV PYTHONUNBUFFERED=1\r\nRUN mkdir -p /data/web/\r\nRUN python -m pip install --upgrade pip\r\nWORKDIR /data/web/\r\nADD requirements.txt /data/web/\r\n# 用国内的源速度快很多\r\nRUN pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/\r\n# ADD . /code/\r\n```\r\n\r\n## docker-compose.yml\r\n\r\n```docker\r\nversion: \'3\' # 有三个版本 必须使用3\r\n\r\nservices:\r\n  mysql:\r\n    image: mysql:5.7\r\n    volumes:\r\n      - ./mysql:/var/lib/mysql\r\n    expose:\r\n      - \"3306\"\r\n    restart: always\r\n    environment:\r\n      - MYSQL_ROOT_PASSWORD=root\r\n      - MYSQL_DATABASE=blog\r\n#      - MYSQL_USER=blog # 直接使用root\r\n#      - MYSQL_PASSWORD=blog\r\n\r\n  nginx:\r\n    image: nginx:alpine\r\n    volumes:\r\n      - ./nginx/nginx.conf:/etc/nginx/nginx.conf\r\n      - ./nginx/conf:/etc/nginx/conf.d\r\n#      - ./web/staticfiles:/django_static\r\n      - ./web/collectedstatic:/django_static\r\n    ports:\r\n      - \"80:80\"\r\n    depends_on:\r\n      - web\r\n\r\n  redis:\r\n    image: redis:alpine\r\n    expose:\r\n      - \"6379\"\r\n    restart: always\r\n\r\n  web:\r\n    build: .\r\n    # command: python manage.py runserver 0:8000\r\n    # ports:\r\n    #   - \"8000:8000\"\r\n    command: uwsgi --ini uwsgi.ini\r\n    working_dir: /data/web\r\n    volumes:\r\n      - ./web:/data/web\r\n    expose:\r\n      - \"8000\"\r\n    depends_on:\r\n      - mysql\r\n      - redis\r\n\r\n  celery:\r\n    build: .\r\n    command: celery -A web worker -l info\r\n    working_dir: /data/web\r\n    volumes:\r\n      - .:/data\r\n    depends_on:\r\n      - mysql\r\n      - redis\r\n```\r\n\r\n### Makefile\r\n只是为了少敲写代码 可以直接用下面的命令代替\r\n```\r\nbuild:\r\n	docker-compose build\r\n\r\nup:\r\n	docker-compose up -d\r\n\r\nup-non-daemon:\r\n	docker-compose up\r\n\r\nstart:\r\n	docker-compose start\r\n\r\nstop:\r\n	docker-compose stop\r\n\r\nrestart:\r\n	docker-compose stop && docker-compose start\r\n\r\nshell-nginx:\r\n	docker exec -ti nginx bash\r\n\r\nshell-web:\r\n	docker exec -ti web bash\r\n\r\nshell-db:\r\n	docker exec -ti mysql bash\r\n\r\nlog-nginx:\r\n	docker-compose logs nginx\r\n\r\nlog-web:\r\n	docker-compose logs web\r\n\r\nlog-db:\r\n	docker-compose logs mysql\r\n\r\ncollectstatic:\r\n	 docker-compose exec web /bin/sh -c \"python manage.py collectstatic --noinput\"\r\n```\r\n\r\n### 项目配置setting.py\r\n```python\r\n# 与容器配置的一致\r\nDATABASES = {\r\n    \'default\': {\r\n        # \'ENGINE\': \'django.db.backends.sqlite3\',\r\n        # \'NAME\': os.path.join(BASE_DIR, \'db.sqlite3\'),\r\n        \'ENGINE\': \'django.db.backends.mysql\',\r\n        \'HOST\': \'mysql\',  # 这个host是容器的名字\r\n        \'PORT\': \'3306\',\r\n        \'NAME\': \'blog\',\r\n        \'USER\': \'root\',\r\n        \'PASSWORD\': \'root\',\r\n\r\n    }\r\n}\r\n```\r\n\r\n### nginx配置\r\n\r\nnginx.conf\r\n```\r\nuser  nginx;\r\nworker_processes  1;\r\n\r\nerror_log  /var/log/nginx/error.log warn;\r\npid        /var/run/nginx.pid;\r\n\r\n\r\nevents {\r\n    worker_connections  1024;\r\n}\r\n\r\n\r\nhttp {\r\n    include       /etc/nginx/mime.types;\r\n    default_type  application/octet-stream;\r\n\r\n    log_format  main  \'$remote_addr - $remote_user [$time_local] \"$request\" \'\r\n                      \'$status $body_bytes_sent \"$http_referer\" \'\r\n                      \'\"$http_user_agent\" \"$http_x_forwarded_for\"\';\r\n\r\n    access_log  /var/log/nginx/access.log  main;\r\n\r\n    sendfile        on;\r\n    #tcp_nopush     on;\r\n\r\n    keepalive_timeout  65;\r\n\r\n    #gzip  on;\r\n\r\n    include /etc/nginx/conf.d/*.conf;\r\n}\r\n\r\n```\r\ndefault.conf\r\n```\r\nserver {\r\n    listen                  80;\r\n    server_name             localhost;\r\n    charset                 utf-8;\r\n    client_max_body_size    10M;\r\n\r\n    location /static/ {\r\n    # root与alias主要区别在于nginx如何解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务器文件上。\r\n    #root的处理结果是：root路径＋location路径\r\n    #alias的处理结果是：使用alias路径替换location路径\r\n    #alias是一个目录别名的定义，root则是最上层目录的定义\r\n        alias   /django_static/;\r\n    }\r\n\r\n    location / {\r\n        include     uwsgi_params;\r\n        uwsgi_pass  web:8000;\r\n    }\r\n}\r\n```\r\n\r\n### 项目依赖 requirements.txt\r\n```\r\nuwsgi==2.0.18\r\ncelery==4.3.0\r\nredis==3.3.6\r\nappdirs==1.4.3\r\nasn1crypto==0.24.0\r\nastroid==2.2.5\r\nattrs==19.1.0\r\nbottle==0.12.17\r\ncertifi==2019.6.16\r\ncffi==1.12.3\r\nchardet==3.0.4\r\ncoverage==4.5.4\r\ncryptography==2.7\r\nDjango==2.2.4\r\ndjango-appconf==1.0.3\r\ndjango-autoslug==1.9.6\r\ndjango-compressor==2.3\r\ndjango-debug-toolbar==2.0\r\ndjango-haystack==2.8.1\r\ndjango-ipware==2.1.0\r\ndjango-mdeditor==0.1.16\r\ndjango-uuslug==1.1.8\r\nelasticsearch==7.0.0\r\nelasticsearch-dsl==7.0.0\r\nidna==2.8\r\nipaddress==1.0.22\r\nisort==4.3.21\r\njieba==0.39\r\njsonpickle==1.2\r\nlazy-object-proxy==1.4.1\r\nmarkdown2==2.3.8\r\nmccabe==0.6.1\r\nmistune==0.8.4\r\nmysqlclient==1.4.2.post1\r\nolefile==0.46\r\npackaging==19.1\r\nPillow==6.1.0\r\npycparser==2.19\r\nPygments==2.4.2\r\npylint==2.3.1\r\npyparsing==2.4.2\r\npython-dateutil==2.8.0\r\npython-logstash==0.4.6\r\npython-memcached==1.59\r\npython-slugify==3.0.3\r\npytz==2019.2\r\nraven==6.10.0\r\nrcssmin==1.0.6\r\nrequests==2.22.0\r\nrjsmin==1.1.0\r\nsix==1.12.0\r\nsqlparse==0.3.0\r\ntext-unidecode==1.2\r\ntyped-ast==1.3.1\r\nUnidecode==1.1.1\r\nurllib3==1.25.3\r\nwebencodings==0.5.1\r\nWeRoBot==1.9.0\r\nWhoosh==2.7.4\r\nwrapt==1.11.2\r\nxmltodict==0.12.0\r\n# django-dotenv==1.4.2\r\n# gunicorn==19.9.0\r\n# psycopg2==2.7.7\r\n```\r\n\r\n### uwsgi启动参数 uwsgi.ini\r\n\r\n```\r\n[uwsgi]\r\nsocket=:8000\r\nchdir=/data/web\r\nmodule=web.wsgi:application\r\npidfile=/tmp/web-master.pid\r\nmaster=True\r\nvacuum=True\r\nprocesses=1\r\nmax-requests=5000\r\n```\r\n\r\n### 开始敲命令部署\r\n\r\n```bash\r\n\r\n# 将代码上传到服务器 可以使用fabric自己搞也行\r\ngit clone xxx\r\n\r\n# 到项目根目录直接创建容器\r\nmake up\r\n\r\n# 执行上面的时候，各个容器都会输出日志，检查容器创建没有异常的话 创建数据库\r\ndocker-compose exec mysql bash\r\n\r\n# 进入到容器后 登陆mysql 账号密码都是root 然后创建数据库 设置字符集\r\nCREATE DATABASE IF NOT EXISTS blog default charset utf8 COLLATE utf8_general_ci;\r\n\r\n# 数据库迁移\r\ndocker-compose exec web bash\r\npython manage.py makemigrations\r\npython manage.py migrate\r\n\r\n# 生成静态文件到nginx的托管目录.托管目录是宿主机上的一个文件夹\r\npython manage.py collectstatic\r\n\r\n# 创建admin用户\r\npython manage.py createsuperuser\r\n\r\n# 访问你设置在nginx.conf中的域名\r\nsundazhong.com\r\n\r\n# 测试下功能是否都正常 都正常的话 把debug关了 \r\n\r\n# 因为是个人搞着玩的 不用太认真 可以相应的写个生产版本的docker-compose.yml\r\n\r\n```\r\n\r\n## 碰到的问题\r\n### 1. mysql容器能启动，但是一连接，服务就会挂掉，原因是宿主机mysql文件夹属组权限问题，更改宿主机的mysql文件夹属组权限\r\n```bash\r\ncd mysql\r\nchown -R root:root ./\r\n```\r\n\r\n### 2. 无法makemigration,提示乱码，无法数据库迁移。数据库字符集没有指定utf8。\r\n\r\n### 3. 还有一些小问题，单个容器进去看看一步一步调，就知道怎么回事了，就不继续说了。\r\n\r\n## TODOLIST\r\n\r\n有一些问题，但是现在有比这个更紧急的事情，所以先放着了。先留着吧\r\n\r\n### 1. setting.py中的数据库配置，host是\"mysql\"，怎么通过一个字符串连接到了mysql的容器。\r\n\r\n### 2. win10和linux的文件系统的区别，就是说有些在本地跑是没问题的，到了服务器就会出现错误，除了文件权限的事情。\r\n\r\n### 3. celery的项目应用是怎么样的\r\n\r\n### 4. 如何启用多个web容器，或者多个数据库容器，怎么去管理\r\n\r\n### 5. 版本发布的问题','2019-08-13 05:33:29.000000','p','o','a',503,0,1,3),(3,'2019-08-13 07:00:50.256933','2019-08-13 07:00:50.256939','设计模式','# 设计模式\r\n\r\n这个看了至少四遍了，看了又忘，忘了又看。文章大部分都是在别人的基础上摘抄过来的，\r\n再加上了自己一点理解过程。这里只列一个大纲。设计模式用的恰到好处是需要经验积累的，不过分设计，也不局限与复制粘贴。\r\n\r\n## 面向对象\r\n\r\n### 继承\r\n\r\n用途\r\n\r\n1. 获得了父类的全部功能，并做出自己的改变或者扩展\r\n2. 定义一个接口类和一些未实现的函数名，子类继承接口类，并实现接口中的方法\r\n\r\n第一种意义不大，使得子类和基类出现强耦合\r\n第二种接口继承，抽象规定了一个兼容接口，使得外界不用关心具体细节，可一视同仁的处理实现了该接口的对象\r\npython没有interface关键字，如果非要去模仿接口的概念，可以借助第三方模块\r\n\r\n### 抽象类\r\n\r\n抽象类是一个特殊的类，一群类共同的函数集合。只能被实现，不能被继承。水果就是一个抽象类。\r\n\r\n### 接口和抽象类的不同\r\n\r\n1. 抽象类强调的是一组类的相似性，包括属性和方法\r\n2. 接口强调的是函数的相似性\r\n\r\n\r\n## 设计模式的六大原则\r\n\r\n### 单一职责原则\r\n\r\n就一个类而言，应该仅有一个引起他变化的原因\r\n软件设计真正要做的很多内容，就是发现职责并把这些职责相互分离。\r\n目的就是提高代码的可维护性、可读性、扩展性\r\n\r\n### 开放封闭原则（开闭原则）\r\n\r\n举例：邓小平提出的一国两制，社会主义不能改变，那就添加一个资本主义制度。\r\n开放-封闭原则：是说软件实体（类、模块、函数等待）应该可以扩展，但是不能修改。两个特征：\r\n\r\n- 对于扩展是开放的\r\n- 对于更改是关闭的\r\n\r\n### 依赖倒转原则\r\n\r\n针对接口编程，不要针对实现编程。无论主板、、CPU、内存、硬盘都是针对接口设计的，而不是针对到某个品牌设计\r\n\r\n- 高层模块不应该依赖底层模块。两个都应该依赖抽象\r\n- 抽象不应该依赖细节。细节应该依赖抽象\r\n\r\n### 里氏代换原则\r\n\r\n子类型必须能够替换它们的父类型，定义了什么是父子。假如A能胜任B的全部事情，那么B就是A的父亲。不能在B的基础上覆盖。\r\n\r\n### 迪米特法则\r\n\r\n妈妈说不要和陌生人说话，只和自己直接的朋友交谈。是你的就别给别人，不是你的就别拿。\r\n\r\n### 接口隔离原则\r\n\r\n客户端不应该依赖它不需要的接口。\r\n在特定的场景下，如果很多类实现了同一个接口，并且都只实现了接口的极少部分方法，这时候很有可能就是接口隔离性不好，就要去分析能不能把方法拆分到不同的接口。根据具体业务具体分析。\r\n\r\n## 设计模式分类\r\n\r\n因为都过了几遍了，在这里列举出来，是为了能有个大纲的印象，不知道怎么去组织代码的时候，看两眼，可能就清楚了，不清楚的再去看详细的例子。\r\n\r\n### 七大结构型模式\r\n\r\n- 桥接模式\r\n- 适配器模式\r\n- 组合模式\r\n- 装饰模式\r\n- 外观模式\r\n- 享元模式\r\n- 代理模式\r\n\r\n### 五大创建型模式\r\n\r\n- 单例模式\r\n- 工厂模式\r\n- 抽象工厂\r\n- 建造者模式\r\n- 原型模式\r\n\r\n### 十一大行为型模式\r\n\r\n- 模板方法\r\n- 中介者模式\r\n- 命令模式\r\n- 责任链模式\r\n- 策略模式\r\n- 迭代器模式\r\n- 观察者模式\r\n- 状态模式\r\n- 备忘录模式\r\n- 解释器模式\r\n- 访问者模式','2019-08-13 06:39:13.000000','p','o','a',89,0,1,5),(4,'2019-08-13 07:48:51.654099','2019-08-13 07:48:51.654109','单例设计模式','# 单例设计模式\r\n\r\n必须满足以下三点\r\n\r\n1. 自己实例化，不能被别人实例化\r\n2. 只能有一个实例\r\n3. 像整个系统提供这个实例\r\n\r\n## **懒汉模式**\r\n\r\n```java\r\n/**\r\n * 延时加载 但是有线程安全问题\r\n * 在多线程并发下，如果两个线程同时执行 instance == null，就会有两个实例\r\n */\r\npublic class SingletonLazy {\r\n	private static SingletonLazy instance=null;	//类加载时就被初始化	\r\n	// static方法可以用对象.方法名来调用，也可以用类名.方法名来调用 在加载的时候先于main方法加载在内存中的数据共享区  static方法是加载一次，被所有的对象所共享。\r\n	public static SingletonLazy getInstance() {\r\n		if(instance==null) {\r\n			instance=new SingletonLazy();\r\n		}\r\n		return instance;\r\n	}\r\n	private SingletonLazy() {}	//私有构造器  只能自己创建\r\n}\r\n```\r\n\r\n## **饿汉模式**\r\n\r\n```java\r\n/**\r\n * \r\n * 在类加载时创建对象实例 \r\n * 不会有线程安全问题\r\n * 不管用不用  都会在类加载时创建\r\n *\r\n */\r\npublic class SingletonHungry {		//饿汉模式\r\n	\r\n	private SingletonHungry() {}\r\n	\r\n	private static SingletonHungry instance=new SingletonHungry();  //类加载时就创建这个实例\r\n\r\n	public static SingletonHungry getInstance() {	\r\n		return instance;\r\n	}\r\n}\r\n\r\n```\r\n\r\n## **main方法测试**\r\n\r\n```java\r\n\r\n/**\r\n * 测试代码\r\n */\r\npublic class Test extends Thread{		//继承thread类 并重写run方法  然后start开启线程\r\n\r\n	public static void main(String[] args) {\r\n		Test t1=new Test();\r\n		Test t2=new Test();\r\n		Test t3=new Test();\r\n		t1.run();\r\n		t2.run();\r\n		t3.run();\r\n	}\r\n	\r\n	//打印每一个实例的内存地址 判断是否单例\r\n	public void run() {\r\n		System.out.println(SingletonLazy.getInstance());		\r\n//		System.out.println(SingletonHungry.getInstance());		\r\n	}\r\n}\r\n\r\n```\r\n\r\n## **懒汉模式优化1**\r\n\r\n```java\r\npublic class SingletonLazy {\r\n	private static SingletonLazy instance=null;\r\n	public sychronized static SingletonLazy getInstance() { //加上sychronized关键字\r\n		if(instance==null) {\r\n			instance=new SingletonLazy();\r\n		}\r\n		return instance;\r\n	}\r\n	private SingletonLazy() {}\r\n}\r\n```\r\n\r\n## **懒汉模式优化2**\r\n\r\n```java\r\npublic class SingletonLazy {\r\n	private static SingletonLazy instance=null;\r\n	public static SingletonLazy getInstance() {\r\n		synchronized(SingletonLazy.class){  //加同步代码块\r\n			if(instance==null) {\r\n				instance=new SingletonLazy();\r\n			}\r\n		}\r\n		return instance;\r\n	}\r\n	private SingletonLazy() {}\r\n}\r\n```\r\n\r\n## **懒汉模式优化3**\r\n\r\n```java\r\npublic class SingletonLazy {\r\n	private static SingletonLazy instance=null;\r\n	public static SingletonLazy getInstance() {\r\n		if(instance==null) {		//判断为空时才进入同步代码块\r\n			synchronized(SingletonLazy.class){\r\n				if(instance==null) {\r\n					instance=new SingletonLazy();\r\n				}\r\n			}\r\n		}\r\n		return instance;\r\n	}\r\n	private SingletonLazy() {}\r\n}\r\n```\r\n\r\n## **懒汉模式优化4**\r\n\r\n```java\r\npublic class SingletonLazy {\r\n	private static SingletonLazy instance=null;\r\n	static {		//static代码块在类加载的时候最开始执行并且只会执行一次\r\n		instance=new SingletonLazy();\r\n	}\r\n	public static SingletonLazy getInstance() {\r\n		return instance;\r\n	}\r\n	private SingletonLazy() {};\r\n}\r\n```\r\n\r\n## **懒汉模式优化5**\r\n\r\n```java\r\npublic class SingletonLazy {\r\n	//利用静态内部类 在调用的时候执行一次 不调用的时候不会执行\r\n	private static class single{\r\n		private static SingletonLazy instance=new SingletonLazy();\r\n	}\r\n	\r\n	public static SingletonLazy getInstance() {\r\n		return single.instance;\r\n	}\r\n	\r\n	private SingletonLazy() {};\r\n}\r\n```\r\n\r\n## python使用继承的方法实现单例\r\n```python\r\nclass Singleton(object):\r\n\r\n    _single = None\r\n\r\n    def __init__(self):\r\n        pass\r\n\r\n    def __new__(cls, *args, **kwargs):\r\n        if not cls._single:\r\n            _single = object.__init__(cls)\r\n\r\n        return _single\r\n\r\n\r\nclass Demo(Singleton):\r\n    pass\r\n\r\n\r\nd1 = Demo()\r\nd2 = Demo()\r\n\r\nprint(id(d1) == id(d2))\r\n\r\n```','2019-08-13 07:47:37.000000','p','o','a',78,0,1,5),(5,'2019-08-13 07:50:47.437470','2019-08-13 07:50:47.437476','简单工厂模式','# 简单工厂模式\r\n1. 不用面向对象\r\n\r\n```javascript\r\n// 写一个计算器 实现简单运算\r\n\r\nfunction calculator(a, b, c) {\r\n	// js中 会返回Infinity 不用捕获异常\r\n	// try {\r\n		switch (c) {\r\n			case \"+\":\r\n				return a + b\r\n			case \"-\":\r\n				return a - b\r\n			case \"*\":\r\n				return a * b\r\n			case \"/\":\r\n				return a / b\r\n		}\r\n	// } catch (e) {\r\n		// console.log(e.name + \": \" + e.message);\r\n	// }\r\n}\r\n\r\na = calculator(1, 0, \"/\") // 输出 Infinity\r\nconsole.log(a);\r\n\r\n```\r\n\r\n2. 封装，将页面逻辑和业务逻辑分离开，解耦。分离开，容易扩展。\r\n3. 需求：能动态的添加开根号运算符。\r\n4. 通过传入参数 获得对应的计算类 通过添加计算类和分支 使得别的计算类不受影响','2019-08-13 07:49:11.000000','p','o','a',76,0,1,5),(6,'2019-08-13 07:51:53.616700','2019-08-13 07:51:53.616706','代理模式','# 代理模式\r\n\r\n> 为其他对象提供一个代理以控制对这个对象的访问\r\n\r\n## 应用场景：\r\n\r\n1. 远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象在于不同地址空间的事实\r\n2. 虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。\r\n\r\n示例：懒加载的实现。代理存储了真实图片的路径\r\n\r\n```html\r\n\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n	<title>图片的懒加载-------代理模式</title>\r\n</head>\r\n<body>\r\n\r\n</body>\r\n<script type=\"text/javascript\">\r\nvar myImage = (function(){\r\n	var imgNode = document.createElement(\"img\");\r\n	document.body.appendChild(imgNode);\r\n	return function(src){\r\n		console.log(\"src=====\"+src);\r\n		imgNode.src = src; \r\n	}\r\n})();\r\n// 代理模式\r\nvar ProxyImage = (function(){\r\n	var img = new Image();\r\n	console.log(\"111\")\r\n	img.onload = function(){\r\n		console.log(\"22222\")\r\n		myImage(this.src);\r\n	};\r\n	return function(src) {\r\n		// 占位图片loading\r\n		console.log(\"333333\")\r\n		myImage(\"http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif\");\r\n		setTimeout(function(){\r\n			img.src = src;\r\n		},3000)\r\n	}\r\n})();\r\n// 调用方式\r\n\r\nProxyImage(\"https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png\"); // 真实要展示的图片\r\n</script>\r\n</html>\r\n\r\n```\r\n\r\n- 安全代理 用来控制真实对象访问的权限 用于对象应该有不同的访问权限的时候\r\n- 智能指引 指当调用真实的对象时，代理处理另外一些事\r\n\r\n\r\n```java\r\n\r\ninterface GiveGift{\r\n	\r\n	void giveFolls()\r\n	void giveFlower()\r\n	void giveChocolate()\r\n}\r\n\r\nclass Pursuit implement GiveFift{\r\n\r\n	MM mm;\r\n	construct(mm){\r\n	  this.mm = mm\r\n	}\r\n	\r\n	void giveFolls(){\r\n	  print(\"给\" + this.mm + \"送花\")\r\n	}\r\n	void giveFlower(){\r\n	  print(\"给\" + this.mm + \"送花\")\r\n	}\r\n	void giveChocolate(){\r\n	  print(\"给\" + this.mm + \"送花\")\r\n	}\r\n}\r\n\r\nclass Proxy implement GiveFift{\r\n\r\n	Pursuit  daili\r\n\r\n	construct(mm){\r\n		daili = new Pursuit(mm)\r\n	}\r\n	\r\n	void giveFolls(){\r\n		daili.giveFolls()\r\n	}\r\n	void giveFlower(){\r\n		daili.giveFlower()\r\n	}\r\n	void giveChocolate(){\r\n		daili.giveChocolate()\r\n	}\r\n}\r\n```\r\n\r\n代理模式其实就是在访问对象时，引入了一定程序的间接性。因为这种间接性，可以附加多种用途。代理就是真实对象的代表。\r\n\r\n\r\n为其他对象提供一种代理以控制对这个对象的访问\r\n\r\n例子：中国互联网的墙\r\n\r\n``` java\r\n/**\r\n * 中国网络（就是代理）\r\n */\r\nclass ChinnessNetwork implements Internet {\r\n\r\n    private Set<String> disable;\r\n\r\n    private Internet internet;\r\n\r\n    public ChinnessNetwork(Internet internet) {\r\n        this.internet = internet; // 初始化时，代理世界的网络\r\n        this.disable = new HashSet<>();\r\n        this.disable.add(\"www.google.com\");\r\n        this.disable.add(\"www.facebook.com\");\r\n    }\r\n\r\n    @Override\r\n    public String access(String domain) {\r\n        if (disable.contains(domain)) {\r\n            System.out.println(\"禁止访问该网站：\" + domain);\r\n            return \"禁止访问该网站：\" + domain;\r\n        }\r\n        return internet.access(domain);\r\n    }\r\n}\r\n\r\n```','2019-08-13 07:51:38.000000','p','o','a',61,0,1,5),(7,'2019-08-13 07:52:18.839074','2019-08-13 07:52:18.839080','原型模式','# 原型模式\r\n\r\n其实就是从一个对象再创建一个可定制的对象，而且不需要知道任何创建的细节。\r\n\r\n- 效率第一\r\n- 用原型实例指定创建对象的种类，通过克隆原型得到新的对象\r\n- 注意深拷贝和浅拷贝\r\n- 使用场景：有大量的对象创建或者类初始化消耗多资源的场景下可以利用原型模式来优化\r\n\r\n## 应用场景\r\n\r\n一般在初始化的信息不发生变化的情况下，克隆是最好的办法。既隐藏了对象创建的细节，又对性能是大大的提升。不用重新初始化对象，而是动态的获得对象运行时的状态。\r\n\r\n## 示例\r\n\r\n``` python\r\n\r\n# -*- coding: utf-8 -*-\r\n\r\nimport copy\r\n\r\nclass Resume(object):\r\n\r\n	def __init__(self, id, name):\r\n		self.id = id\r\n		self.name = name\r\n\r\n    def set_name(name):\r\n        self.name = name\r\n\r\n	def clone(self):\r\n		return copy.copy(self)\r\n\r\nif __name__ == \"__main__\":\r\n	a = Resume(1,\"sunda\")\r\n	b = a.clone() # 不用重新初始化对象 \r\n    b.set_name(\"sdasd\") # 设置状态信息\r\n	print(b.name)\r\n\r\n```\r\n\r\n## 浅复制和深复制：\r\n\r\n- 浅复制只能复制值类型，\r\n- 不复制引用类型\r\n\r\n浅复制：\r\n\r\n```python\r\n# -*- coding: utf-8 -*-\r\n\r\nimport copy\r\n\r\nclass Resume(object):\r\n\r\n	def __init__(self, id, name):\r\n		self.id = id\r\n		self.name = name\r\n		self.company = Company()\r\n\r\n	def set_name(self, name):\r\n		self.name = name\r\n\r\n	def set_company(self, name):\r\n		self.company.set_name(name)\r\n\r\n	def clone(self):\r\n		return copy.copy(self)\r\n\r\n	def __str__(self):\r\n		return \"ID：【%s】  名字：%s  公司:%s\" %(self.id, self.name, self.company)\r\n\r\nclass Company(object):\r\n\r\n	def set_name(self, name):\r\n		self.name = name\r\n\r\n	def __str__(self):\r\n		return self.name\r\n\r\nif __name__ == \"__main__\":\r\n	a = Resume(1,\"aaaaaaaaa\")\r\n	a.set_company(\"alibaba\")\r\n	b = a.clone() # 不用重新初始化对象 \r\n	b.set_company(\"tencent\")\r\n	\r\n	print(a) # ID：【1】  名字：aaaaaaaaa  公司:tencent\r\n	print(b) # ID：【1】  名字：bbbbbb  公司:tencent\r\n\r\n    # company并没有复制 使用下面的深复制\r\n\r\n```\r\n\r\n深复制\r\n\r\n```python\r\n# -*- coding: utf-8 -*-\r\n\r\nimport copy\r\n\r\nclass Resume(object):\r\n\r\n	# 放在外面一样的\r\n	# id = None\r\n	# name = None\r\n\r\n	def __init__(self, id, name):\r\n		self.id = id\r\n		self.name = name\r\n		self.company = Company()\r\n\r\n	# 可选构造函数\r\n	# 但是还是能经过 self.company = Company() 不能实现深拷贝 舍弃\r\n	@classmethod\r\n	def create(cls):\r\n		return cls(self.id, self.name)\r\n\r\n	@classmethod\r\n	def creat_by_company(cls, company):\r\n		\'\'\'\r\n		先克隆company 然后再赋值\r\n		\'\'\'\r\n		r = cls(0, \"\")\r\n		r.company = company.clone()\r\n		return r\r\n\r\n	def set_name(self, name):\r\n		self.name = name\r\n\r\n	# 还是会经过 self.company = Company() 不能实现深拷贝 舍弃\r\n	# def creat_resume_by_company(self, company):\r\n	# 	r = Resume(self.id, self.name)\r\n	# 	self.company = company.clone()\r\n	# 	self.name = self.name\r\n	# 	self.id = self.id\r\n\r\n	def set_company(self, name):\r\n		self.company.set_name(name)\r\n\r\n	def clone(self):\r\n		# 先克隆\r\n		resume = Resume.creat_by_company(self.company)\r\n		resume.name = self.name\r\n		resume.id = self.id\r\n		return resume\r\n\r\n	def __str__(self):\r\n		return \"ID：【%s】  名字：%s  公司:%s\" %(self.id, self.name, self.company)\r\n\r\nclass Company(object):\r\n\r\n	def set_name(self, name):\r\n		self.name = name\r\n\r\n	def __str__(self):\r\n		return self.name\r\n\r\n	def clone(self):\r\n		# 必须要用copy\r\n		# return self\r\n		return copy.copy(self)\r\n\r\nif __name__ == \"__main__\":\r\n	a = Resume(1,\"aaaaaaaaa\")\r\n	a.set_company(\"alibaba\")\r\n	b = a.clone() # 不用重新初始化对象 \r\n	b.set_name(\"bbbbbb\")\r\n	b.set_company(\"tencent\")\r\n	\r\n	print(a) # ID：【1】  名字：aaaaaaaaa  公司:alibaba\r\n	print(b) # ID：【1】  名字：bbbbbb  公司:tencent\r\n\r\n```','2019-08-13 07:52:04.000000','p','o','a',68,0,1,5),(8,'2019-08-13 07:53:29.888806','2019-08-13 07:53:29.888813','发布订阅模式（观察者模式）','# 发布订阅模式（观察者模式）\r\n\r\n使用场景：当一个对象发生改变需要同时改变其他对象，并且不知道有多少个对象的时候。\r\n\r\n当多个观察者没有一致的update方法时，可以用事件委托 Handler\r\n\r\n- 定义一种一对多的关系，使得一个对象状态发生改变时，则依赖于它的对象都会得到通知，并更新自己\r\n- 举例：朋友圈，你的好友是观察者，自己是被观察者\r\n- 观察者没有统一的更新方法名时，结合使用适配器模式\r\n\r\n## 例子1\r\n\r\n```javascript\r\n\r\n// 主题类 一个主题可以添加多个观察者\r\nvar Subject = (function(){\r\n\r\n	function Subject(name){\r\n		this.observers = []\r\n		this.name = name\r\n		this.action = \"\"\r\n	}\r\n	var _proto = Subject.prototype\r\n\r\n	_proto.attach = function(observer) {\r\n		this.observers.push(observer)\r\n	};\r\n\r\n	_proto.unAttach = function(observer){\r\n		let index = this.observers.indexOf(observer)\r\n		if(index > -1){\r\n			this.observers.splice(index, 1)\r\n		}\r\n	}\r\n\r\n	_proto.notify = function(){\r\n		this.observers.forEach(function(observer){\r\n			observer.update();\r\n		})\r\n	}\r\n\r\n	_proto.updateAction = function(action){\r\n		this.action = action\r\n		this.notify()\r\n	}\r\n\r\n	return Subject\r\n\r\n})()\r\n\r\n// 观察类\r\nvar Observer = (function(){\r\n\r\n	function Observer(name, sub){\r\n		this.name = name\r\n		this.sub = sub\r\n		this.state = \"\"\r\n	}\r\n\r\n	var _proto = Observer.prototype\r\n\r\n	_proto.update = function(){\r\n		this.state = this.sub.state\r\n		console.log(\"状态改变：\" + this.sub.action  + \"  \"+ this.name + \"===========update\")\r\n	}\r\n\r\n	return Observer\r\n\r\n})()\r\n\r\n\r\n//两个主题\r\nvar game_sub = new Subject(\"game sub\")\r\nvar math_sub = new Subject(\"math_sub sub\")\r\n\r\n// 三个观察者订阅\r\nvar o1 = new Observer(\"name:XXX\", game_sub)\r\nvar o2 = new Observer(\"name:YYY\", math_sub)\r\nvar o3 = new Observer(\"name:YYY\", math_sub)\r\n\r\ngame_sub.attach(o1)\r\nmath_sub.attach(o2)\r\nmath_sub.attach(o3)\r\n\r\n// 退订\r\nmath_sub.unAttach(o3)\r\n\r\ngame_sub.updateAction(\"ABC\")\r\nmath_sub.updateAction(\"QWE\")\r\n\r\n```\r\n\r\n## 例子2\r\n\r\n```python\r\n#!/usr/bin/env python\r\n# -*- coding: utf-8 -*-\r\n\"\"\"\r\nCreated by sundazhong on 2019/5/21 22:47.\r\n\r\n\"\"\"\r\n\r\n\r\n\r\nclass Secretary(object):\r\n	\"\"\"\r\n	前台类\r\n	\"\"\"\r\n	observers = []\r\n	action = \"\"\r\n\r\n	def add_observer(self, observer):\r\n		self.observers.append(observer)\r\n		pass\r\n\r\n	def remove_observer(self, observer):\r\n		self.observers.pop(observer)\r\n\r\n	def notify(self):\r\n		\"\"\"\r\n		通知同事不要看了\r\n		:return:\r\n		\"\"\"\r\n		for p in self.observers:\r\n			p.update()\r\n\r\n\r\nclass Observer(object):\r\n	\"\"\"\r\n	看股票的同事\r\n	\"\"\"\r\n\r\n	def __init__(self, name, sub):\r\n		self.name = name\r\n		self.sub = sub\r\n\r\n	def update(self):\r\n		print(u\"%s,%s不看股票了\" % (self.sub.action, self.name))\r\n\r\n\r\nif __name__ == \"__main__\":\r\n	# 前台\r\n	secretary = Secretary()\r\n	# 依赖性太强了  应该依赖抽象 而不是相互依赖\r\n	o1 = Observer(\"o1\", secretary)\r\n	o2 = Observer(\"o2\", secretary)\r\n	secretary.add_observer(o1)\r\n	secretary.add_observer(o2)\r\n\r\n	secretary.action = u\"老板来了\"\r\n	secretary.notify()\r\n\r\n\r\n```\r\n\r\n## 改进例子2\r\n\r\n```python\r\n#!/usr/bin/env python\r\n# -*- coding: utf-8 -*-\r\n\"\"\"\r\nCreated by sundazhong on 2019/5/21 22:47.\r\n\r\n\"\"\"\r\n\r\nimport abc\r\n\r\n\r\nclass Observer(metaclass=abc.ABCMeta):\r\n	\"\"\"\r\n	观察类\r\n	\"\"\"\r\n\r\n	def __init__(self, name, sub):\r\n		self.name = name\r\n		self.sub = sub\r\n\r\n	@abc.abstractmethod\r\n	def update(self):\r\n		pass\r\n\r\n\r\nclass MoviesObserver(Observer):\r\n	\"\"\"\r\n	看电影的同事\r\n	\"\"\"\r\n\r\n	def update(self):\r\n		print(u\"%s,%s不看股票了\" % (self.sub.action, self.name))\r\n\r\n\r\nclass GameObserver(Observer):\r\n	\"\"\"\r\n	打游戏的同事\r\n	\"\"\"\r\n\r\n	def update(self):\r\n		print(u\"%s,%s不打游戏了\" % (self.sub.action, self.name))\r\n\r\n\r\nclass Subject(metaclass=abc.ABCMeta):\r\n	\"\"\"\r\n	主题类\r\n	\"\"\"\r\n	observers = []\r\n	action = \"\"\r\n\r\n	def __init__(self, name):\r\n		self.name = name\r\n\r\n	@abc.abstractmethod\r\n	def add_observer(self, observer):\r\n		pass\r\n\r\n	@abc.abstractmethod\r\n	def remove_observer(self, observer):\r\n		pass\r\n\r\n	@abc.abstractmethod\r\n	def notify(self):\r\n		pass\r\n\r\n\r\nclass Secretary(Subject):\r\n	\"\"\"\r\n	前台类\r\n	\"\"\"\r\n\r\n	def add_observer(self, observer):\r\n		self.observers.append(observer)\r\n		pass\r\n\r\n	def remove_observer(self, observer):\r\n		\"\"\"\r\n		:param observer: Observer\r\n		:return:\r\n		\"\"\"\r\n		self.observers.pop(observer)\r\n\r\n	def notify(self):\r\n		\"\"\"\r\n		通知同事不要看了\r\n		:return:\r\n		\"\"\"\r\n		for p in self.observers:\r\n			p.update()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n\r\n	# 观察者和主题都解耦合了\r\n	# 定义了一种一对多的关系 让多个观察者同事监听一个主题的状态变化\r\n	# 这个状态发生变化时，会通知观察者更新自己\r\n\r\n	# 也就是当前台告诉同事老板来了的时候 同事都开始工作了\r\n\r\n	# 第三种 大话设计模式  pdf:137页\r\n\r\n	secretary = Secretary(\"lll\")\r\n	o1 = MoviesObserver(\"o1\", secretary)\r\n	o2 = GameObserver(\"o2\", secretary)\r\n	secretary.add_observer(o1)\r\n	secretary.add_observer(o2)\r\n\r\n	secretary.action = u\"老板来了\"\r\n	secretary.notify()\r\n\r\n```\r\n\r\n## 当观察者没有统一的update方法时，可以使用委托\r\n\r\n```python\r\n#!/usr/bin/env python\r\n# -*- coding: utf-8 -*-\r\n\r\n\r\nclass Demo(object):\r\n\r\n	def __init__(self):\r\n		pass\r\n\r\n	# def update(self):\r\n		# print(u\"停止了手上的事，去工作了！！\")\r\n\r\n	def go_to_work(self):\r\n		print(\"部分委托：去工作--------\")\r\n\r\n	def test_all_proxt(self):\r\n		print(\"全部委托：------\")\r\n\r\n\r\nclass Proxy(object):\r\n\r\n	def __init__(self):\r\n		self.demo = Demo()\r\n\r\n	def update(self):\r\n		self.demo.go_to_work()\r\n\r\n	def __getattr__(self, name):\r\n		return getattr(self.demo, name)\r\n\r\nif __name__ == \"__main__\":\r\n	p = Proxy()\r\n	p.update() # 部分委托 ，当Demo没有同意的update方法时\r\n	p.test_all_proxt() # 利用__getattr__来实现大量委托的效果\r\n\r\n\r\n```','2019-08-13 07:52:28.000000','p','o','a',61,0,1,5),(9,'2019-08-13 07:54:03.423259','2019-08-13 07:54:03.423266','备忘录模式','#备忘录模式\r\n\r\n示例：游戏读档\r\n\r\n> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将对象恢复到原先保存的状态。\r\n\r\n使用场景：适用于功能比较复杂，需要维护或记录属性历史的类，或者需要保存的属性只是众多属性中的一部分时。  \r\n对象的一些属性保存在对象之外。\r\n\r\n例子：数据库回滚机制','2019-08-13 07:53:40.000000','p','o','a',71,0,1,5),(10,'2019-08-13 07:55:28.754078','2019-08-13 07:55:28.754084','外观模式','### 外观模式\r\n> 为子系统中的一组接口提供一个一直的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。  \r\n\r\n举例：基金。把很多人的闲散资金融合起来去买股票，而不是每个人都买股票。\r\n\r\n\r\n统一口径，一直对外\r\n\r\n例子：\r\n外观模式通过一个对外统一的接口，隐藏了内部的具体实现，使得外部系统可以更加简单的访问，也减少了外部系统对内部系统的依赖，从上面的例子讲，如果开发同学开发一半生病短时间无法来上班，交接给其他同学，由组长内部安排解决，需求同学并不需要知道。外观模式在微服务交互之间经常使用。\r\n\r\n这个就是我们的外观模式，我们的技术组长就是外观模式的象征，他专门对外提供接收需求服务，然后安排需求给开发同学和测试同学，保证完成','2019-08-13 07:54:06.000000','p','o','a',58,0,1,5),(11,'2019-08-13 07:55:59.848413','2019-08-13 07:55:59.848423','工厂模式','#工厂模式\r\n> - 简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态的实例化相关的类，去除了具体产品的依赖.\r\n> - 工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。\r\n\r\n- 定义一个用于创建对象的接口，让子类决定实例化哪一个类。\r\n- 简单工厂，扩展性弱，违反开闭原则\r\n- 在单产品多层级，层级数量不多的情况下，可以使用简单工厂','2019-08-13 07:55:42.000000','p','o','a',70,0,1,5),(12,'2019-08-13 07:56:25.996043','2019-08-13 07:56:25.996049','建造者模式','### 建造者模式\r\n\r\n>讲一个复杂的对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。\r\n\r\n用于建造顺序是稳定的。但是建造细节复杂多变的情况下。\r\n\r\n- 使用场景：创建复杂的对象\r\n- 复杂的步骤抽象成接口，具体类单独实现，各自有builder类控制顺序返回构建的实例','2019-08-13 07:56:10.000000','p','o','a',64,0,1,5),(13,'2019-08-13 07:57:46.882958','2019-08-13 07:57:46.882964','模板方法模式','### 模板方法模式\r\n> 当我们要完成在某一个细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法来处理。  \r\n父类定义框架，子类具体实现，在掌握中自由发挥\r\n\r\n举例子：抄黑板的题目考试  对比 直接发试卷考试\r\n定义一个操作中的算法的骨架。而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构就可以重定义该算法的某些特定步骤。\r\n\r\n把不变行为搬移到超类，去除子类的重复代码提现它的优势。','2019-08-13 07:57:35.000000','p','o','a',60,0,1,5),(14,'2019-08-13 07:58:06.654652','2019-08-13 07:58:06.654659','状态模式','### 状态模式\r\n\r\n> 当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。\r\n- 当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。\r\n- 当超过 3 层的 if-else 的逻辑判断代码，推荐用状态模式来重构代码\r\n- 例子：自身状态的改变导致自身行为的改变\r\n- 降低代码复杂性 提高可维护性\r\n\r\n\r\n当一个对象的行为取决于它的状态时，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式了。','2019-08-13 07:57:55.000000','p','o','a',59,0,1,5),(15,'2019-08-13 08:00:20.826150','2019-08-13 08:00:20.826157','策略模式','## 策略模式\r\n> 面向对象的编程。并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的抽象集合才是类。\r\n\r\n- 定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。\r\n- 举例：洗衣机的各种模式\r\n- 和简单工厂模式一起使用，可以是策略对象不对外暴露\r\n\r\n需求： 商城收银软件 \r\n1. 打折 七折 八折 半折 等\r\n2. 满300减100 \r\n3. 打五折并且满500-200\r\n4. 或者满100积分送10积分\r\n5. 怎么利用设计模式编写健壮性强的代码\r\n\r\n简单工厂模式：将每中收费方式做成工厂，商城可能经常性的更改打折额度或者返利额度，每次维护或者扩展收费方式都要更改工厂，很糟糕。\r\n\r\n### 策略模式：\r\n> 它定义了算法家族。分别封装起来，让她们可以相互替换，此模式让算法的变化不会影响使用算法的客户。\r\n\r\n策略模式是一种定义了一系列算法的方法。完成的都是相同的工作，只是实现不同。\r\n\r\n优点：\r\n- 具体实现类为Context定义了一系列的可供重用的算法和行为，又助于抽出公共的功能。即：收费\r\n- 简化了单元测试 因为每个算法都有自己的类，可以通过自己的接口单独测试。\r\n-','2019-08-13 08:00:04.000000','p','o','a',73,0,1,5),(16,'2019-08-13 08:01:28.367205','2019-08-13 08:01:28.367213','组合模式','### 组合模式\r\n\r\n> 将对象组合成树形结构以表示\'部分-整体\'的层次结构。使得用户对单个对象和组合对象的使用具有一致性。\r\n\r\n例子：假设目前有一家公司，技术部就 4 个人，大熊担任经理，中熊担任组长，小熊1和小熊2担任工程师\r\n\r\n伪代码\r\n```\r\n\r\n抽象类，它有这 3 个角色共有的特性，名称设置获取以及显示数据\r\nclass person\r\n\r\n  init():\r\n    this.employees = [] // 工程师没有这个属性（下属）及下面的方法，但是在抽象类定义了。 这种称为：透明模式。\r\n\r\n  init():  \r\n    pass  // 如果抽象类不将这个属性抽象，而是分别在子类声明和实现，称为：安全模式\r\n\r\n  add_employees()\r\n\r\n  remove_employees()\r\n\r\n\r\n实现经理类\r\nclass manage extends person\r\n\r\n实现组长类\r\nclass group extends person\r\n\r\n实现小熊\r\nclass x extends person\r\n```','2019-08-13 08:01:15.000000','p','o','a',60,0,1,5),(17,'2019-08-13 08:01:49.845908','2019-08-13 08:01:49.845926','装饰者模式','### 装饰者模式  \r\n> 动态的给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活。装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象。\r\n\r\n应用场景：新加的代码装饰了原有类的核心职责或主要行为。\r\n\r\n\r\n**装饰某个对象，让一个功能单一的对象拥有一些其他的功能，这些功能的添加是动态的。用户可以随意的扩展原有对象的功能。一方面代替了继承，相对于继承带来的功能扩展，装饰器模式可以理解为动态的扩展，用户需要什么就扩展什么功能，非常灵活，而继承带来的缺点就是不方便修改，是静态的扩展。由于他的方便也带来了缺点，在装饰的过程中，其实创建了很多的对象占据内存资源，这些对象大多都很相似，排查错误也是有很大困难。**\r\n\r\n\r\n```java\r\n//定义一个抽象的接口 名字和价格\r\npublic interface AbstractComputer {\r\n	String name();\r\n	String price();\r\n}\r\n```\r\n\r\n\r\n```java\r\n//实现接口 创建一个acer 4200的电脑\r\npublic class Computer implements AbstractComputer{\r\n\r\n	@Override\r\n	public String name() {\r\n		return \"acer\";\r\n	}\r\n\r\n	@Override\r\n	public String price() {\r\n		return \"4200\";\r\n	}\r\n\r\n}\r\n\r\n```\r\n\r\n```java\r\npublic class HardDisk implements AbstractComputer{\r\n\r\n	private AbstractComputer computer;\r\n	\r\n	public HardDisk(AbstractComputer computer){\r\n		this.computer=computer;\r\n	}\r\n	\r\n	@Override\r\n	public String name() {\r\n		return computer.name()+\"加硬盘\";\r\n	}\r\n\r\n	@Override\r\n	public String price() {\r\n		return computer.price()+\"加硬盘用了335\";\r\n	}\r\n\r\n}\r\n```\r\n\r\n```java\r\npublic class Test {\r\n\r\n	public static void main(String[] args) {\r\n		Computer computer=new Computer();\r\n		System.out.println(computer.name()+\"      \"+computer.price());\r\n		\r\n		HardDisk hd=new HardDisk(computer);\r\n		System.out.println(\"利用装饰模式\"+hd.name()+\"   \"+ hd.price());\r\n	}\r\n}\r\n\r\n```\r\n\r\n**结果**\r\n\r\n```java\r\nacer      4200\r\n利用装饰模式acer加硬盘   4200加硬盘用了335\r\n\r\n```\r\n\r\n**装饰器模式很好的体现开闭原则：对于扩展是开放的，对于修改是关闭的。用户可以动态添加功能。在java的io流中也是应用了装饰器模式。在装饰的过程中最重要的就是子类继承父类，在执行子类的构造方法的时候，会隐式调用super()**\r\n\r\n\r\n在给一个类添加附加功能的时候，很有用。在一些类与类之间有叠加效应。\r\n\r\n例子：很多糖水店会提供几种龟苓膏，比如普通龟苓膏、蜂蜜龟苓膏、牛奶龟苓膏。或者蜂蜜+牛奶\r\n\r\n伪代码：\r\n\r\n```\r\n\r\nclass guilinggao()\r\n  def init\r\n  \r\n  def process()\r\n      print(\"龟苓膏\")\r\n\r\n// 装饰类\r\nclass Decorator extends gunlinggao():\r\n\r\n   init(g)\r\n     this.guilinggao = g\r\n\r\n   def process():\r\n      this.guilinggao.process()\r\n\r\n// 蜂蜜\r\n\r\nclass fengmi extends Decorator():\r\n\r\n   init(g)\r\n     super(g)\r\n\r\n   def process():\r\n     this.guilinggao.process()\r\n     print(\"加蜂蜜\")\r\n\r\n// 牛奶\r\nclass niunai extends Decorator():\r\n\r\n   init(g)\r\n     super(g)\r\n\r\n   methods process():\r\n     this.guilinggao.process()\r\n     print(\"加牛奶\")\r\n\r\n\r\ng = fengmi()\r\nf_and_n = niunai(g) //此时 龟苓膏就是又加牛奶又加蜂蜜了\r\n\r\n```','2019-08-13 08:01:37.000000','p','o','a',40,0,1,5),(18,'2019-08-13 08:14:55.414909','2019-08-13 08:14:55.414916','适配器模式','# 适配器模式\r\n\r\nAdapter 将一个类的接口转换成客户希望的另外一个接口。\r\nAdapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\r\n\r\n使用场景：在双方都不太容易修改的时候再使用适配器模式来适配\r\n\r\n1. 类适配器模式\r\n2. 对象适配器模式\r\n\r\n```java\r\n\r\nclass Adapter{\r\n    // 适配 \r\n    private Player p\r\n    \r\n    public void attack(){\r\n        p.attack()\r\n    }\r\n}\r\n\r\nclass Player{\r\n    \r\n    public void attack(){\r\n        \r\n    }\r\n}\r\n\r\n```','2019-08-13 08:14:40.000000','p','o','a',66,0,1,5),(19,'2019-08-13 08:24:30.003377','2019-08-13 08:24:30.003384','桥接模式','# 桥接模式 \r\n>- 将抽象和实现独立结构，使得两者可以独立的变化\r\n- 桥接模式利用了聚合的优点去解决继承的缺点，使得抽象和实现进行分离解耦\r\n\r\n- 例子：目前手机有安卓手机和苹果手机，软件有谷歌浏览器和火狐浏览器，通过桥接模式实现手机打开软件。\r\n\r\n伪代码：\r\n```\r\n// 手机抽象类\r\nabstract class Phone\r\n  // 实例方法  参数 软件\r\n  methods openSoftware(software)\r\n  	software.open(this)\r\n\r\n// 安卓手机\r\nclass Android implements phone\r\n\r\n// 苹果手机\r\nclass IPhone implements phone\r\n\r\n// 抽象软件类 \r\nabstract class Software\r\n\r\n  // 手机实例做参数\r\n  open(phone)\r\n    print(phone + \"打开\" + this.name)\r\n\r\n// 谷歌浏览器\r\nclass google implements Software\r\n\r\n// 火狐浏览器\r\nclass fox implements Software\r\n\r\n```','2019-08-13 08:18:33.000000','p','o','a',71,0,1,5),(20,'2019-08-13 08:37:04.652223','2019-08-13 08:37:04.652230','享元模式','## 享元模式\r\n\r\n共享富贵,使用共享对象可有效地支持大量的细粒度的对象。\r\n\r\n例子：小红和小明用蜡笔画同一副画。小明画了草和路，小红画了树和蓝天。都用了绿色的蜡笔画树和草。在软件实现过程中，新建了 2 次绿色蜡笔，也就是在整个作画过程中，小明和小红并不是共用一套蜡笔，而是各自用一套蜡笔。享元模式实现方法相当于我们蜡笔都放在了笔袋，小明和小红用完就放到笔袋里面，每一种颜色的蜡笔只有一根，也就是他们共用一套蜡笔。\r\n\r\n代码：\r\n\r\n```java\r\n\r\n/**\r\n * 笔袋\r\n */\r\nclass CrayonFactory {\r\n\r\n    private static Map<String, ICrayon> data = new HashMap<>();\r\n\r\n    public static ICrayon getCrayon(String color) {\r\n        if (data.containsKey(color)) {\r\n            return data.get(color);\r\n        }\r\n        ICrayon crayon = new Crayon(color);\r\n        data.put(color, crayon);\r\n        return crayon;\r\n    }\r\n\r\n}\r\n\r\n```\r\n平时开发过程中经常见到这种因为很多重复的对象，所以利用享元模式来实现的场景。\r\n享元模式合理提高了对象的复用性，减少了程序的内存占用，还有一个提高性能的地方就是减少了对象创建的过程','2019-08-13 08:36:44.000000','p','o','a',64,0,1,5),(21,'2019-08-13 09:07:08.819573','2019-08-13 09:07:08.819580','抽象工厂','# 抽象工厂\r\n\r\n- 为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类\r\n- 层级多且需要支持扩展，可以使用工厂方法；在多产品多层级，可以使用抽象工厂','2019-08-13 09:06:50.000000','p','o','a',431,0,1,5),(22,'2019-08-13 09:32:08.953657','2019-08-13 09:32:08.953663','中介者模式','# 中介者模式\r\n\r\n- 用一个中介封装一系列对象的交互，减少了不必要的依赖，降低耦合\r\n- 举例：MVC框架，Controller将视图和业务逻辑分离开','2019-08-13 09:31:48.000000','p','o','a',79,0,1,5),(23,'2019-08-13 09:32:58.346807','2019-08-13 09:32:58.346814','命令模式','## 命令模式\r\n\r\n- 将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能\r\n- 类的解耦，是调用者和接受者没有任何关系，增强扩展性\r\n- 跟中介者有什么区别？？？\r\n- 代码例子还没有','2019-08-13 09:32:38.000000','p','o','a',73,0,1,5),(24,'2019-08-13 09:34:38.545893','2019-08-13 09:34:38.545899','责任链模式','## 责任链模式\r\n\r\n- 使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。\r\n- 当前的处理类中有下一个处理类的引用\r\n- 责任链很好的将后面的处理逻辑封装起来了\r\n- 举例：Filter过滤器、三层面试','2019-08-13 09:33:08.000000','p','o','a',81,0,1,5),(25,'2019-08-13 09:35:46.345625','2019-08-13 09:35:46.345631','迭代器模式','## 迭代器模式\r\n\r\n- 它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。\r\n- 加上迭代器可以让容器有统一的遍历代码风格，不用各自去实现遍历方法，有更好的封装性\r\n- 例子：Java 中访问 MySQL 获取数据','2019-08-13 09:35:33.000000','p','o','a',333,0,1,5),(26,'2019-08-13 09:40:37.769078','2019-08-13 09:40:37.769085','解释器模式','## 解释器模式\r\n\r\n- 对 2 个不同的表达方式进行转换，让本来不懂的内容解释成看得懂的\r\n- 例子：翻译','2019-08-13 09:40:22.000000','p','o','a',324,0,1,5),(27,'2019-08-13 09:42:16.833891','2019-08-13 09:42:16.833897','访问者模式','## 访问者模式\r\n\r\n- 封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作\r\n- 访问者模式有比较好的扩展性\r\n- 不好的地方，就是把被访问者暴露给访问者，使得访问者可以直接了解被访问者的所有东西\r\n- 没理解透，找个例子？？？','2019-08-13 09:42:00.000000','p','o','a',270,0,1,5),(28,'2019-08-13 11:26:24.903586','2019-08-13 11:26:24.903593','mongodb','### mongoDB\r\n是一个基于分布式文件存储的数据库，旨为web应用提供可扩展的共性能数据存储解决方案\r\n\r\n### 关系型数据库ACID规则\r\n\r\n- Atomicity 原子性 要不全部做完 要不都不做\r\n- Consistency 一致性 数据库要一直处于一致的状态 事务不会改变原本的一致性约束\r\n- Isolation 独立性 并发的事务不会相互影响 \r\n- Durability 持久性 事务提交后 即使宕机数据也在\r\n\r\n### 分布式\r\n多台计算机和通信的软件通过计算机网络连接组成\r\n容错、可扩展、资源共享、灵活、更快的速度、开放系统、更高的性能、\r\n\r\n### NoSQL\r\nnot only sql\r\n\r\n\r\n### 对比\r\n\r\nRDBMS\r\n- 高度组织化结构化数据\r\n- 结构化查询语言 SQL\r\n- 数据和关系都在单独的表中\r\n- 数据操纵语言、数据定义语言\r\n- 严格的一致性\r\n- 基础食物  \r\n\r\nNoSQL\r\n- 代表的不仅仅是sql\r\n- 没有声明性查询语言\r\n- 没有预定义的模式\r\n- 键值对存储、列存储、文档存储、图形数据库\r\n- 最终一致性 而非ACID属性\r\n- CAP定理 ：\r\n    - 一致性（Consistency）所有节点同一时间数据相同\r\n    - 可用性（Availability） 请求不管成功与否都有响应\r\n    - 分区容错（Partition tolerance） 任意信息的丢失都不会影响系统的运行\r\n    - 不可能同时满足 将NoSQL分为满足CA、CP、AP原则三大类\r\n- 高性能、高可用性、可伸缩性\r\n\r\n\r\n### NoSQL的优点和缺点\r\n优点：\r\n- 高可扩展性\r\n- 分布式计算\r\n- 低成本\r\n- 架构的灵活性、半结构化数据\r\n- 没有复杂的关系\r\n\r\n缺点：\r\n- 没有标准化\r\n- 有限的查询功能\r\n- 最终一致是不直观的程序\r\n\r\n\r\n### BASE\r\n是NoSQL数据库通常对可用性和一致性的弱要求原则\r\n- 基本可用\r\n- 软状态/柔性事务\r\n- 最终一致性  也是ACID的最终目的\r\n\r\n\r\n### 数据库分类\r\n- 列存储:\r\n    - Hbase\r\n    - Cassandra\r\n    - Hypertable\r\n- 文档存储\r\n    - MongoDB\r\n    - CouchDB\r\n- kv存储\r\n    - Tokyo Cabinet\r\n    - Tyrant\r\n    - Berkeley DB\r\n    - MemcacheDB\r\n    - Redis\r\n- 图存储\r\n    - Neo4j\r\n    - FlockDB\r\n- 对象存储(通过对象的方式存取数据)\r\n    - db4o\r\n    - Versant\r\n- xml数据库（支持XML的内部查询语法，比如XQuery、Xpath）\r\n    - Berkeley DB XML\r\n    - BaseX','2019-08-13 11:25:17.000000','p','o','a',188,0,1,6),(29,'2019-08-13 11:27:29.672267','2019-08-13 11:27:29.672275','mysql','### mysql常用操作\r\n\r\n目前这些都是一些很基础的操作，还要几天才能整理完mysql的东西，是一个mindmaster文件，想办法看能不能放上来。\r\n更新一下。:facepunch: :smiley:\r\n\r\n## 查询过程\r\n1. 处理连接，一个连接一个线程\r\n2. 非系统表查询会查询缓存\r\n3. 解析优化，本身是发了一个文本给mysql服务器\r\n4. 存储引擎（各种不同的存储引擎向上边的MySQL server层提供统一的调用接口。真实数据在不同存储引擎中存放的格式一般是不同的）\r\n\r\n## innodb\r\n0. 在Indodb中，数据就是索引，索引就是数据，会在索引建立的时候，自动建立一个索引按照设定的排序的b+树\r\n1. 默认存储引擎\r\n2. 将数据分为若干个页，页是磁盘和内存交互的基本单位，也是mysql管理存储空间的基本单位\r\n3. 页的大小一般为16kb\r\n4. 以记录为单位存放数据，这个记录称为行格式，存放在数据页的user record内\r\n5. 行格式：compact、Redundant、Dynamic和Compressed行格式。在原理上大体都是相同的\r\n6. compact格式，分为额外信息，数据信息。额外信息分为：变长字段长度列表、null值列表、记录头信息（row_id（如果指定了主键就没有）、事务id、回滚id）\r\n	- 记录头信息由head_no信息记录了在页中的位置\r\n	- 记录头信息中有 record_type字段，0是普通记录 1是目录记录（非叶子节点） 2 是最小记录 3 是最大记录\r\n	- 记录头有指向下一个页的指针，所以是一个按照fk排序的单链表\r\n	- 记录头信息有delete_mask字段，标记是否删除，标记已删除和放入垃圾链表等待回收利用是两个步骤\r\n11. Redundant是MySQL5.0之前用的一种行格式\r\n12. Dynamic是默认的行格式\r\n13. Compressed、Dynamic和上面的区别是在处理溢出数据的时候，会全部存到新的页，不会像compact用到前768个字节。\r\n14. Compressed会采用压缩算法对页面进行压缩，以节省空间\r\n15. 非叶子节点，也就是目录项只有主键值和页的编号两个列\r\n16. 各个存放目录项的页也是根据页中用户记录的主键大小顺序排成一个双向链表\r\n17. 通过二级索引查询，只能查询到主键和索引的数据，如果需要全部字段，需要到聚簇索引中回表查询全部信息。\r\n\r\n## 字符集和比较规则\r\n1. 字符映射成一个二进制数据的过程也叫做编码，二进制数据映射到一个字符的过程叫做解码\r\n2. ascii\r\n3. ios-8859-1(iatin1)\r\n4. gb2312\r\n5. gbk\r\n6. utf8\r\n7. utf8mb3 在mysql中，为了节省大小，使用三个字节表示一个字符。\r\n8. 如果要使用四个字节表示一个字符，用utf8mb4\r\n9. 保持三个变量的值和客户端使用的字符集相同。character_set_client、character_set_connection、character_set_results\r\n\r\n## 事务\r\n1. 脏写（改了别的事务没提交的数据，）\r\n2. 脏读（别的事务还没提交，就读到了数据）\r\n3. 不可重复读（读到了别的事务更改）\r\n4. 幻读（读到了别的事务新增的数据）\r\n\r\n\r\n## 其他\r\n1. union是多个结果，再去重，union all没有去重\r\n2. explain + sql, 查询该sql的执行计划 可以加参数 format=json\r\n3. \r\n\r\n## 常用操作\r\n\r\n* 导出数据库 \r\n	```\r\n	./mysqldump -h127.0.0.1 -uroot -p FKGameDB  > /Users/air/Desktop/game.sql\r\n	```\r\n\r\n* 导入 ： \r\n	```\r\n	source /Users/air/Desktop/game.sql;\r\n	```\r\n* 当前某张表是否有死锁，谁拥有表上的这个锁等\r\n	```\r\n	show open tables where In_use > 0;\r\n	```\r\n\r\n* 存储过程 \r\n  \r\n  存储在数据库中供所有用户调用的子程序（ 也是数据库中的一个对象）存储过程和存储函数的不同点：存储过程不能不能return，函数能return结果使用存储过程的场景：使用于操作多张表及复杂更改数据时，有利于代码的编写，一次编译，直接调用，速度快。但减弱了系统的可移植性。\r\n\r\n* 用utf8创建数据库\r\n	```\r\n	CREATE DATABASE IF NOT EXISTS manage default charset utf8 COLLATE utf8_general_ci;\r\n	```\r\n\r\n* mysql开启、关闭、重启\r\n	\r\n	使用Homebrew安装的mysql \r\n		```\r\n		cd /usr/local/Cellar/mysql@5.5/5.5.60/support-files\r\n		# 停止\r\n		./mysql.server start\r\n		./mysql.server stop\r\n		./mysql.server restart\r\n		```\r\n		\r\n## 学mysql的一些操作记录，先留着\r\n```sql\r\n# select * from student,score where score.number = student.number;\r\n# select * from student as a left join score as b on a.number = b.number;\r\n# select * from score as a left join student as b on a.number = b.number;\r\n# select * from student as a right join score as b on a.number = b.number;\r\n\r\n# 查看执行计划\r\n# explain select * from student as a right join score as b on a.number = b.number;\r\n# 详细计划\r\n# explain format = json select * from student as a right join score as b on a.number = b.number;\r\n# explain format = json select stu.name, sco.score from student as stu left join score as sco on stu.number = sco.number where sco.number is not null;\r\n# 在执行完上面的format=json语句后，还可以通过下面这句查看计划的扩展信息。\r\n# show warnings ;\r\n\r\n\r\n# 追踪语句具体的执行过程\r\n# 1. 打开optimizer trace功能 (默认情况下它是关闭的):\r\n# SET optimizer_trace=\"enabled=on\";\r\n\r\n# 2. 这里输入你自己的查询语句\r\n# select stu.name, sco.score from student as stu left join score as sco on stu.number = sco.number where sco.number is not null;\r\n# 3. 从OPTIMIZER_TRACE表中查看上一个查询的优化过程\r\nSELECT * FROM information_schema.OPTIMIZER_TRACE;\r\n\r\n# 4. 可能你还要观察其他语句执行的优化过程，重复上边的第2、3步\r\n\r\n# 5. 当你停止查看语句的优化过程时，把optimizer trace功能关闭\r\n# SET optimizer_trace=\"enabled=off\";\r\n\r\n\r\n\r\n# 设置Innodb的缓存大小 最小是5m 在mysql启动的时候就会分配一个连续的内存占用\r\n# innodb_buffer_pool_size = 268435456\r\n\r\n# 还面试了一个去重\r\n# select distinct t1.a, t1.c  from demo_inner t1\r\n\r\n# 自连接\r\n\r\n```','2019-08-13 11:27:03.000000','p','o','a',159,0,1,6),(30,'2019-08-13 11:28:04.485075','2019-08-13 11:28:04.485081','redis','1.连接redis\r\n```\r\nredis-cli -h 127.0.0.1 -p 6379 -a password\r\n```\r\n\r\n2. 实时监测\r\n```\r\nMONITOR\r\n```\r\n\r\n## redis \r\n### 1.介绍\r\n支持key-value等多种数据结构的存储系统  \r\n用于缓存、事件发布、或订阅、高速队列等场景  \r\n使用ansic语言编写  \r\n支持网络 提供字符串 哈希 列表 队列 集合结构直接存取 \r\n基于内存 可持久化\r\n\r\n### 2. 应用场景\r\n1. 会话缓存 \r\n2. 消息队列 比如支付\r\n3. 活动排行榜或计数\r\n4. 发布、订阅消息（消息通知）\r\n5. 商品列表、评论列表\r\n   \r\n### 3. 数据类型\r\n1. string  \r\n>键值最大存512M  ( get || set || getset || mget )\r\n2. hash\r\n>string类型的field和value的映射表  ( hget || hset || hmset || hmget )    \r\n3. list\r\n>字符串列表，按照插入的顺序排序  ( lpush || rpush || lrange)\r\n4. set\r\n>string类型的无序集合 不可以重复 ( sadd || smembers || srem ) \r\n1. zset(sorted set)\r\n>string类型的有序集合 不可以重复 set中的每个元素都需要指定一个分数 根据分数升序排序  ( zadd || zcount || zscore || zrem || zrangebyscore )\r\n\r\n### 4.相关命令\r\n\r\n1. select 选择数据库 （0-15）\r\n2. quit\r\n3. info\r\n4. monitor 实时监控\r\n5. config get  获得服务配置\r\n6. flushdb 删除当前选择的数据库中的key\r\n7. flushall 删除所有库中的key\r\n\r\n### 5.dedis的发布和订阅（pub/sub）\r\n三个客户端同时订阅一个频道。当有新消息发送到频道1时，就会发送给订阅它的三个客户端','2019-08-13 11:27:47.000000','p','o','a',93,0,1,6),(31,'2019-08-13 11:30:01.160221','2019-08-13 11:30:01.160228','mysql批量备份数据','## 备份脚本\r\n\r\n补上数据库的备份脚本，其实就是一行命令，奈何记不住，好在简单\r\n\r\n```python\r\n#!/usr/bin/env python\r\n# -*- coding: utf-8 -*-\r\n\r\n\r\nimport os\r\nimport time\r\nimport datetime\r\n\r\n# 定义ip，用户名、密码\r\n\r\nDB_HOST = \'localhost\'\r\nDB_USER = \'root\'\r\nDB_USER_PASSWD = \'\'\r\n\r\n# 脚本所在文件夹\r\nbash_path = os.path.dirname(os.path.realpath(__file__))\r\n\r\n# 数据库名称（多个库分行放置）和备份的路径\r\nDB_NAME = os.path.join(bash_path, \'dbnames.txt\')\r\n\r\n# 备份文件夹\r\nBACKUP_PATH = os.path.join(bash_path, \"mysql\")\r\n\r\nDATETIME = time.strftime(\'%Y%m%d-%H%M%S\')\r\nTODAYBACKUPPATH = os.path.join(bash_path, \"mysql%s\" % DATETIME)\r\n\r\n\r\n# 执行备份脚本，读取文件中的数据库名称\r\n# 注意按行读写，不校验是否存在该库\r\ndef run_backup():\r\n	print(u\"从dbname.txt获取数据库列表\")\r\n	f = open(DB_NAME, \"r\")\r\n	for dbname in f.readlines():\r\n		print(u\"开始备份数据库：%s\" % dbname)\r\n		dbname = dbname.strip()\r\n		dumpcmd = \"mysqldump -u\" + DB_USER + \" -p\" + DB_USER_PASSWD + \" \" + dbname + \" > \" + TODAYBACKUPPATH + \"/\" + dbname + \".sql\"\r\n		print(dumpcmd)\r\n		os.system(dumpcmd)\r\n	f.close()\r\n\r\n\r\n# 执行压缩的函数\r\ndef run_tar():\r\n	print(u\"开始压缩\")\r\n	if not os.path.exists(BACKUP_PATH):\r\n		os.makedirs(BACKUP_PATH)\r\n\r\n	compress_file = TODAYBACKUPPATH + \".tar.gz\"\r\n	compress_cmd = \"tar -czvf \" + compress_file + \" \" + (\"mysql%s\" % DATETIME)\r\n	print(compress_cmd)\r\n\r\n	os.system(compress_cmd)\r\n	print(u\"压缩完成!\")\r\n\r\n	# 删除备份文件夹\r\n	remove_cmd = \"rm -rf \" + TODAYBACKUPPATH\r\n	os.system(remove_cmd)\r\n\r\n	# 移动到mysql文件夹\r\n	mv_cmd = \"mv %s %s\" % (compress_file, BACKUP_PATH)\r\n	os.system(mv_cmd)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n	# 创建备份文件夹\r\n	print(u\"创建备份文件夹!\")\r\n	if not os.path.exists(TODAYBACKUPPATH):\r\n		os.makedirs(TODAYBACKUPPATH)\r\n\r\n	if os.path.exists(DB_NAME):\r\n		run_backup()\r\n		run_tar()\r\n	else:\r\n		print(u\"请在当前文件夹中创建文件：dbname.txt，输入备份的数据库名称，多个库分行放置\")\r\n\r\n```','2019-08-13 11:29:01.000000','p','o','a',86,0,1,6),(32,'2019-08-13 11:31:41.880917','2019-08-13 11:31:41.880923','git常用命令','### git\r\n\r\n1. tag\r\n```\r\ngit tag v1.5 \"commit的标识\" -m \'xxxxxxxxxx\'\r\ngit push origin --tags //上传\r\n```\r\n\r\n2. gitignore不生效\r\n```\r\n git rm -r --cached . \r\n git add . \r\n git commit -m \'update .gitignore\'\r\n```\r\n\r\n3. 不提交更改 但是可以暂存更改 并切换到其他的分支\r\n```\r\ngit stash \r\n```','2019-08-13 11:31:01.000000','p','o','a',115,0,1,7),(33,'2019-08-13 11:32:27.634834','2019-08-13 11:32:27.634840','gitbook','# GitBook\r\n\r\n## install\r\n\r\n1. npm install gitbook-cli -g\r\n2. gitbook init\r\n3. gitbook install 安装插件\r\n4. gitbook serve\r\n5. gitbook build\r\n6. 推荐编辑器：vscode + Markdown Preview Enhanced插件\r\n7. 详见[Gitbook](src/tools/gitbook.md)\r\n\r\n## Plugins\r\n\r\n- editlink # 编辑本页\r\n- disqus 网站评论插件\r\n    > 要翻墙 可以用gitalk代替，使用github的issue生成评论，暂时用不上\r\n- baidu 百度统计插件 用不上\r\n- sitemap 网站地图\r\n- github 显示仓库地址\r\n- prism # 使用插件高亮\r\n- splitter # 侧边栏宽度调节\r\n- tbfed-pagefooter # footer说明\r\n- fontsettings # 字体设置\r\n- simple-page-toc # 不用 直接用浮动了\r\n    > 生成单页的目录，不支持中文，在需要添加目录的地方添加```<!-- toc -->```\r\n- links # 链接\r\n- code # 代码行数和复制按钮\r\n- search-pro # 搜索支持中文\r\n- pageview-count # 文件阅读数\r\n- lightbox # 查看图片\r\n- advanced-emoji # 表情\r\n    > https://www.webfx.com/tools/emoji-cheat-sheet/\r\n- anchor-navigation-ex # 添加toc悬浮 只有h1-h3会显示\r\n- expandable-chapters-small # 菜单折叠 换了\r\n- expandable-chapters # 菜单折叠 换了\r\n- toggle-chapters # 菜单折叠 换了\r\n- chapter-fold # 菜单折叠\r\n- anchors # 锚点\r\n\r\n## other\r\n\r\n1. 查看单个插件详细地址：\r\n\r\n    > https://www.npmjs.com/package/gitbook_plugin_disqus（disqus）\r\n\r\n2. book.json中，带-标记的表示去除自带插件\r\n3. h标题从1开始写\r\n4. 添加表情的时候 前面要加空格 否则就是不是生成img','2019-08-13 11:31:55.000000','p','o','a',98,0,1,7),(34,'2019-08-13 12:12:34.437547','2019-08-13 12:12:34.437553','为什么要做这个博客网站','- 方便查询，比如一些常用的代码片段、工具之类的。\r\n- 写点东西，很能静下心\r\n- 慢慢扩展网站功能，也是一种锻炼\r\n- 提高语言组织能力、文档写作能力\r\n- 写文档的过程就是对知识的总结和消化\r\n- 本身比较浮躁 :disappointed:\r\n\r\n因为是以前的一些杂七杂八的东西整理出来的，加上本身经验也不够，所以前期内容都是一些简单的东西。慢慢来吧。\r\n共勉。:facepunch: :facepunch:\r\n\r\n看了几天书，发现效率好低，只是有个概念，该忘记还是得忘，所以换种方式，直接敲代码。然后记录过程。\r\n\r\n\r\n2019-08-14 01:14:58 星期三\r\n\r\nBUG:\r\n> - ~~在后台使用图标时，不显示。~~ 2019-08-16 00:50:22 星期五\r\n> - 上传图片的时候，如果文件名带了()会有问题。2019-08-16 00:50:31 星期五\r\n\r\nTODOLIST:\r\n> - 知乎下载视频集成到一个页面 2019-08-16 00:51:41 星期五\r\n> - 做一个可以TODOLIST功能和BUG的功能 2019-08-16 00:51:42 星期五','2019-08-13 12:01:06.000000','p','o','a',138,0,1,1),(35,'2019-08-15 03:25:19.367454','2019-08-15 03:25:19.367461','正则表达式','关于正则表达式一些好用的网站\r\n\r\n- [正则表达式文档](https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md \"正则表达式练习\")\r\n- [正则表达式可视化](https://regexper.com/# \"正则表达式可视化\")\r\n- [正则表达式测试和生成](https://c.runoob.com/front-end/854 \"正则表达式测试和生成\")','2019-08-15 03:22:13.000000','p','o','a',92,0,1,7),(36,'2019-08-15 11:17:45.596265','2019-08-15 11:17:45.596271','JavaScript中对象复制','Javascript中的对象只是内存中某个位置的引用。 这些引用是可变的，即它们可以被重新分配。 \r\n因此，简单地复制了个引用只会导致这两个引用指向了内存中的相同位置。\r\n```javascript\r\nvar foo = {\r\n	a: \"abc\"\r\n}\r\nvar bar = foo;\r\nconsole.log(foo.a) // abc\r\nbar.a = \"qwe\"\r\n\r\nconsole.log(foo.a);//qwe\r\nconsole.log(bar.a);//qwe\r\n```\r\n执行结果：\r\n![执行结果图](/media/editor/1565885810_20190815111820590230.png \"执行结果图\")\r\n\r\n## 浅复制\r\n\r\n如果你的对象中只有值类型的属性，你可以使用扩展语法或者Object.assign(),也支持多个源。\r\n\r\n```javascript\r\nvar foo = {\r\n	a: \"abc\"\r\n};\r\nvar copy1 = {...foo};\r\nvar copy2 = Object.assign({}, foo);\r\n\r\nconsole.log(copy1)；//同foo\r\nconsole.log(copy2)//同foo\r\n\r\n// 多个源\r\nvar bar = {\r\n	b : \"qwe\"\r\n}\r\nvar copy3 = Object.assign({}, foo, bar); // copy3 = {a:\"abc\",b:\"qwe\"}\r\n// 或者\r\nvar copy4 = {...foo, ...bar}; // copy3 = {a:\"abc\",b:\"qwe\"}\r\n```\r\n\r\n## 深复制\r\n上述方法的问题在于，对于那些具有对象类型的属性的对象，只有引用被复制了，即它相当于执行了var bar = foo;\r\n\r\n### 方法1：一个可行的解决方案是先将对象序列化为字符串，然后再将其反序列化回来：\r\n\r\n仅适用于对象的值类型可序列化并且没有循环引用才有效。\r\n```\r\n\r\nvar obj = {a:0,b:{c：0}}\r\nvar copy = JSON.parse(JSON.stringify(obj))\r\n\r\n```\r\n### 方法2： 一种HTML5克隆算法 叫structured clone的。背后的思路是利用通信功能来应用序列化算法。因为没有提供直接的方法来调用这个算法\r\n\r\n### 方法3：自己写\r\n\r\n```javascript\r\nfunction deepClone(obj){\r\n	var copy;\r\n	if(null==obj||\"object\"!=typeof obj){\r\n		return obj\r\n	}\r\n	if(obj instanceof Date){\r\n		copy = new Date();\r\n		copy.setTime(obj.getTime())\r\n		return copy;\r\n	}\r\n	\r\n	if(obj instanceof Array){\r\n		copy = [];\r\n		for(var i=0,len=obj.length;i<len;i++){\r\n			copy[i] = clone(obj[i]);//递归处理数组\r\n		}\r\n		return copy;\r\n	}\r\n	\r\n	if(obj instanceof Function){\r\n		copy = function(){\r\n			return obj.apply(this, arguments);\r\n		}\r\n		return copy\r\n	}\r\n	\r\n	if(obj instanceof Object){\r\n		copy = {}\r\n		for(var attr in obj){\r\n			if(obj.hasOwnProperty(attr)){\r\n				copy[attr] = clone(obj[attr])\r\n			}\r\n		}\r\n		return copy\r\n	}\r\n	\r\n	throw new Error(\"Unable to copy obj as type isn\'t supported\" + obj.constructor.name)\r\n}\r\n```\r\n\r\n\r\n觉得这个在工作中用的还是比较多的。','2019-08-15 11:12:22.000000','p','o','a',127,0,1,8),(37,'2019-08-17 03:58:59.917916','2019-08-17 03:58:59.917922','生成器、迭代器、列表推导式','## 列表推导式\r\n支持多级循环，每一级也支持多项条件，但是代码不易理解\r\n```python\r\nm = [[1,2,3],[1,2,3,4]]\r\narr = [item for row in m for item in row]\r\n# [1,2,3,1,2,3,4]\r\n```\r\n\r\n生成器和迭代器代码：\r\n\r\n```python\r\narr1 = [i for i in range(4)]  # 列表推导式\r\nprint(arr1)\r\n\r\n# 列表生成器\r\n# 1. 自动实现迭代器协议\r\n# 2. 状态挂起：生成器使用yield语句返回一个值。\r\n# 3. 生成器只能遍历一次\r\narr = (i for i in range(4))\r\n# print(list(arr)) # 生成器转list 转了之后就不是生成器了\r\n\r\nprint(arr)\r\n\r\nprint(next(arr))\r\nprint(next(arr))\r\nprint(next(arr))\r\n```\r\n\r\n## 迭代器\r\n\r\n任意对象，只要定义了next(Python2) 或者__next__方法，它就是一个迭代器。就这么简单。现在我们来理解迭代(iteration)\r\n\r\n## 可迭代对象\r\nPython中任意的对象，只要它定义了可以返回一个迭代器的__iter__方法，\r\n或者定义了可以支持下标索引的__getitem__方法，那么它就是一个可迭代对象。\r\n简单说，可迭代对象就是能提供迭代器的任意对象\r\n\r\n\r\n## 迭代\r\n\r\n用简单的话讲，它就是从某个地方（比如一个列表）取出一个元素的过程。当我们使用一个循环来遍历某个东西时，这个过程本身就叫迭代。\r\n\r\n## 生成器\r\n\r\n生成器也是一种迭代器，但是你只能对其迭代一次。这是因为它们并没有把所有的值存在内存中，而是在运行时生成值。你通过遍历来使用它们，要么用一个“for”循环，要么将它们传递给任意可以进行迭代的函数和结构。\r\n大多数时候生成器是以函数来实现的。然而，它们并不返回一个值，而是yield(暂且译作“生出”)一个值\r\n\r\n生成器最佳应用场景是：你不想同一时间将所有计算出来的大量结果集分配到内存当中，特别是结果集里还包含循环。\r\n\r\n```python\r\ndef generator_function():\r\n    for i in range(10):\r\n        yield i\r\n\r\nfor item in generator_function():\r\n    print(item)\r\n\r\n```\r\n下面是一个计算斐波那契数列的生成器：\r\n```python\r\n# generator version\r\ndef fibon(n):\r\n    a = b = 1\r\n    for i in range(n):\r\n        yield a\r\n        a, b = b, a + b\r\n# 使用\r\nfor x in fibon(1000000):\r\n    print(x)\r\n```\r\n\r\n## 内置函数：next()，获取一个序列的下一个元素\r\n\r\n```python\r\ndef generator_function():\r\n    for i in range(3):\r\n        yield i\r\n\r\ngen = generator_function()\r\nprint(next(gen))\r\n# Output: 0\r\nprint(next(gen))\r\n# Output: 1\r\nprint(next(gen))\r\n# Output: 2\r\nprint(next(gen))\r\n# Output: Traceback (most recent call last):\r\n#            File \"<stdin>\", line 1, in <module>\r\n#         StopIteration\r\n```\r\n\r\n## 内置函数，iter,将根据一个可迭代对象返回一个迭代器对象\r\n\r\n```python\r\nmy_string = \"Yasoob\"\r\nmy_iter = iter(my_string)\r\nnext(my_iter)\r\n# Output: \'Y\'\r\n```\r\n\r\n## map\r\n\r\n```python\r\n# 不使用map\r\nitems = [1, 2, 3, 4, 5]\r\nsquared = []\r\nfor i in items:\r\n    squared.append(i**2)\r\n\r\n# 使用map\r\nitems = [1, 2, 3, 4, 5]\r\nsquared = list(map(lambda x: x**2, items))\r\n\r\n# 使用在一个列表的函数\r\ndef multiply(x):\r\n        return (x*x)\r\ndef add(x):\r\n        return (x+x)\r\n\r\nfuncs = [multiply, add]\r\nfor i in range(5):\r\n    value = map(lambda x: x(i), funcs)\r\n    print(list(value))\r\n\r\n# Output:\r\n# [0, 0]\r\n# [1, 2]\r\n# [4, 4]\r\n# [9, 6]\r\n# [16, 8]\r\n```\r\n\r\n## filter\r\nfilter过滤列表中的元素，并且返回一个由所有符合要求的元素所构成的列表，符合要求即函数映射到该元素时返回值为True\r\n\r\n```python\r\nnumber_list = range(-5, 5)\r\nless_than_zero = filter(lambda x: x < 0, number_list)\r\nprint(list(less_than_zero))\r\n```\r\n\r\n## Reduce\r\n当需要对一个列表进行一些计算并返回结果时，Reduce 是个非常有用的函数。\r\n```python\r\nfrom functools import reduce\r\nproduct = reduce( (lambda x, y: x * y), [1, 2, 3, 4] )\r\n\r\n# Output: 24\r\n```','2019-08-17 03:30:53.000000','p','o','a',94,0,1,2),(38,'2019-08-17 04:36:57.633373','2019-08-17 04:36:57.633379','python装饰器','## python装饰器\r\n\r\n- 一切皆对象\r\n- 高阶函数：可以将函数当成参数传递\r\n\r\n实现简单装饰器\r\n```\r\ndef decorate(func):\r\n    def wrapper():\r\n        print(\"=========before=========\")\r\n        func()\r\n        print(\"=========after=========\")\r\n    return wrapper\r\n\r\ndef hello():\r\n    print(\"hello world!\")\r\n\r\ndecorate(hello)()\r\n\r\n```\r\n@只是一个简短的方式来生成一个被装饰的函数\r\n\r\n```python\r\n\r\ndef decorate(func):\r\n    def wrapper():\r\n        print(\"=========before=========\")\r\n        func()\r\n        print(\"=========after=========\")\r\n    return wrapper\r\n\r\n\r\n@decorate\r\ndef hello():\r\n    print(\"hello world!\")\r\n\r\n\r\nhello()\r\nprint(hello.__name__) # 输出的却是wrapper 重写了执行的函数的名字和注释文档(docstring)\r\n```\r\n\r\n## functools.wraps\r\n解决了执行函数改变问题\r\n```python\r\nfrom functools import wraps\r\ndef decorate(func):\r\n    @wraps(func)\r\n    def wrapper():\r\n        print(\"=========before=========\")\r\n        func()\r\n        print(\"=========after=========\")\r\n    return wrapper\r\n\r\n@decorate\r\ndef hello():\r\n    print(\"hello world!\")\r\n\r\nhello()\r\nprint(hello.__name__) # hello\r\n```\r\n\r\n**@wraps接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等的功能。**\r\n**这可以让我们在装饰器里面访问在装饰之前的函数的属性**\r\n\r\n## 装饰器类\r\n\r\n类也可以用来构建装饰器\r\n```\r\nfrom functools import wraps\r\n\r\nclass logit(object):\r\n    def __init__(self, logfile=\'out.log\'):\r\n        self.logfile = logfile\r\n\r\n    def __call__(self, func):\r\n        @wraps(func)\r\n        def wrapped_function(*args, **kwargs):\r\n            log_string = func.__name__ + \" was called\"\r\n            print(log_string)\r\n            # 打开logfile并写入\r\n            with open(self.logfile, \'a\') as opened_file:\r\n                # 现在将日志打到指定的文件\r\n                opened_file.write(log_string + \'\\n\')\r\n            # 现在，发送一个通知\r\n            self.notify()\r\n            return func(*args, **kwargs)\r\n        return wrapped_function\r\n\r\n    def notify(self):\r\n        # logit只打日志，不做别的\r\n        pass\r\n\r\nclass email_logit(logit):\r\n    \'\'\'\r\n    一个logit的实现版本，可以在函数调用时发送email给管理员\r\n    \'\'\'\r\n    def __init__(self, email=\'admin@myproject.com\', *args, **kwargs):\r\n        self.email = email\r\n        super(email_logit, self).__init__(*args, **kwargs)\r\n\r\n    def notify(self):\r\n        # 发送一封email到self.email\r\n        # 这里就不做实现了\r\n        pass\r\n```\r\n**@email_logit将会和@logit产生同样的效果，但是在打日志的基础上，还会多发送一封邮件给管理员。**','2019-08-17 04:26:51.000000','p','o','a',85,0,1,2),(39,'2019-08-19 22:44:59.791070','2019-08-19 22:44:59.791076','python标准库模块','## atexit\r\n允许注册在程序退出时调用的函数\r\n\r\n## argparse\r\n提供解析命令行参数的函数\r\n\r\n## bisect\r\n为可排序列表提供二分查找算法\r\n\r\n## calendar\r\n提供一组和日期相关的函数\r\n\r\n## codecs\r\n提供一组有用的数据结构\r\n\r\n## collections\r\n提供一组有用的数据结构\r\n\r\n## copy\r\n提供复制数据的函数\r\n\r\n## csv\r\n提供用于读写csv文件的函数\r\n\r\n## datetime\r\n提供处理日期和时间的类\r\n\r\n## fnmatch\r\n提供用于匹配Unix风格文件名模块的函数\r\n\r\n## concurrent\r\n提供异步计算\r\n\r\n## glob\r\n提供用于匹配Unix风格路径模式的函数\r\n\r\n## io\r\n提供用于处理I/O流的函数\r\n\r\n## json\r\n提供用来读写jso格式数据的函数\r\n\r\n## logging\r\n提供对python内置的日志功能的访问\r\n\r\n## multiprocessing\r\n可以在应用程序中运行多个子进程，而且提供api让这些子进程看上去和线程一样\r\n\r\n## operator\r\n提供实现基本的python运算符功能的函数\r\n\r\n## os\r\n提供对基本的操作系统函数的访问\r\n\r\n## random\r\n提供生成伪随机数的函数\r\n\r\n## re\r\n提供正则表达式\r\n\r\n## sched\r\n提供一个无需多线程的事件调度器\r\n\r\n## select\r\n提供对函数select和poll的访问，用于创建事件循环\r\n\r\n## shutil\r\n提供对高级文件处理函数的访问\r\n\r\n## signal\r\n提供用于处理POSIX信号的函数\r\n\r\n## tempfile\r\n提供用于创建临时文件和目录的函数\r\n\r\n## threading\r\n提供对处理高级线程功能的访问\r\n\r\n## urllib、urllib2、urlparse\r\n提供处理和解析url的函数\r\n\r\n## uuid（Universally Unique Identifiers）\r\n生成全局唯一标识符','2019-08-19 22:25:59.000000','p','o','a',78,0,1,2),(40,'2019-08-21 07:24:02.587205','2019-08-21 07:24:02.587212','python多线程和多进程','# Python多线程和多进程\r\n\r\n一个应用程序的可扩展性、并发性、并行性在很大程度上取决于它的初始架构和设计的选择。\r\n\r\n并发：计算机似乎是在同一时间做着很多不同的事。假如电脑只有一个CPU核心，那么操作系统会在各程序之间迅速切换，使其都有机会运行在这个处理器上面。\r\n\r\n并行：计算机确实实在同一时间做着很多不同的事情，具备多个CPU核心的计算机，能够同时执行多个程序，各程序中的指令都分别运行在cpu内核上。\r\n\r\n并行和并发的关键区别就在于能不能提速。某程序如果是并行程序，其中有两条不同的执行路径都在平行的向前推进，则时间会缩短一半，\r\n\r\n\r\n## 多线程\r\n### 定义和使用场景\r\n是在一个python进程中将代码运行在不同的处理器上的能力。意味这代码的不同部分可以并行的运行。\r\n可以用多线程来执行阻塞式I/O，但不要拿来做平行运算。\r\n\r\n使用场景：\r\n1. 需要运行在后台，但不希望停止主线程的执行。\r\n2. 需要将工作负载分布在几个CPU上。\r\n\r\n### GIL\r\nCPython只是一个python的一个可用实现之一，GIL是指Python的全局解释器锁，CPython每次要执行字节码都要先申请这个锁。\r\n意味着通过多线程扩展应用程序，总是会收到这个的限制。除了CPython,JPYthon就没有全局解释器锁，可以有效并行的运行多个线程。\r\n\r\n\r\n### 多线程存在GIL锁\r\n\r\n多线程代码：\r\n```python\r\nimport random\r\n\r\nimport threading\r\n\r\nresults = []\r\n\r\n\r\ndef computer():\r\n    results.append(sum([random.randint(1, 100) for i in range(1000000)]))\r\n\r\n\r\nworkers = [threading.Thread(target=computer) for x in range(8)]\r\n\r\nfor worker in workers:\r\n    worker.start()\r\n\r\nfor worker in workers:\r\n    worker.join()\r\n\r\nprint(\"results:%s\" % results)\r\n```\r\n结果（使用的pycharm的profile run生成的图片）：\r\n![](/media/editor/1234_20190821074015252071.png)\r\n\r\n### 在线程中使用锁来防止数据竞争\r\n\r\n```python\r\nimport threading\r\n\r\n\r\nclass Counter(object):\r\n\r\n    def __init__(self):\r\n        self.count = 0\r\n\r\n    def increment(self, offset):\r\n        self.count += offset\r\n\r\n\r\n# 在传感器读数的过程中，会发生阻塞I/o操作\r\n# 模拟：所以要给每个传感器分配它的工作线程,采集一次读数，就会+1 然后继续采集\r\n\r\ndef worker(sensor_index, how_many, counter):\r\n    for _ in range(how_many):\r\n        counter.increment(1)\r\n\r\n\r\ndef run_threads(func, how_many, counter):\r\n    threads = []\r\n    for i in range(5):\r\n        thread = threading.Thread(target=func, args=(i, how_many, counter))\r\n        threads.append(thread)\r\n        thread.start()\r\n\r\n    for thread in threads:\r\n        thread.join()\r\n\r\n\r\n# how_many = 10 ** 5\r\n# counter = Counter()\r\n# run_threads(worker, how_many, counter)\r\n# print(\"Counter should be %d, found %d\" % (5 * how_many, counter.count))\r\n\r\n\r\n# 结果 ： Counter should be 500000, found 418165\r\n\r\n# 分析\r\n# count += 1\r\n# 拆成\r\n# getattr(counter, count)\r\n# value += 1\r\n# setattr(counter, count)\r\n\r\n# 当线程A获取了值还没来得及相加和覆盖值的时候 B执行进来了 然后B执行完 A继续执行 A加完1并且赋值\r\n# 但是A加的值是以前获取的 相当于完全抹去了B线程做的事情 所以会出现上面这种情况\r\n\r\n# 为了防止诸如此类的数据竞争，data race\r\n# threading提供了Lock类 就是互斥锁 我们可以使用Lock类来保护Counter类\r\n# 同一时刻只有一个线程能获取这把锁\r\n\r\nclass LockingCounter(object):\r\n    def __init__(self):\r\n        self.lock = threading.Lock()\r\n        self.count = 0\r\n\r\n    def increment(self, offset):\r\n        with self.lock:\r\n            self.count += offset\r\n\r\n\r\nhow_many = 10 ** 5\r\ncounter = LockingCounter()\r\nrun_threads(worker, how_many, counter)\r\nprint(\"Counter should be %d, found %d\" % (5 * how_many, counter.count))\r\n# Counter should be 500000, found 500000\r\n```\r\n\r\n### 用queue来协调各个线程之间的工作\r\n```python\r\n\"\"\"\r\n@python 3.6\r\n\r\n如果python需要处理很多事务，那么开发者需要协调这些事务，在各种协调方式中，较为高效的一种是：采用函数管线\r\n\r\n原理: 和生产线差不多  分为很多阶段 每个阶段由一个具体的函数来负责\r\n涉及阻塞式IO操作或者子线程的工作任务 尤其适合使用此方法\r\n\r\n例子：\r\n要构建一个照片处理系统 该系统从数码相机里面持续获取照片 调整尺寸 然后将其添加到网络相册中 \r\n这样的程序可以使用三阶段的管线来做\r\n\r\n任务传递方式:线程安全的生产者和消费者队列来建模\r\n\r\n\"\"\"\r\nfrom collections import deque\r\nfrom threading import Lock, Thread\r\nfrom time import sleep\r\n\r\n\r\nclass MyQueue(object):\r\n\r\n    def __init__(self, name):\r\n        self.name = name\r\n        self.items = deque()\r\n        self.lock = Lock()\r\n\r\n    def put(self, obj):\r\n        \"\"\"\r\n        存放待处理的项目\r\n        :param obj:\r\n        \"\"\"\r\n        with self.lock:\r\n            print(\"%s放入\" % self.name)\r\n            self.items.append(obj)\r\n\r\n    def get(self):\r\n        \"\"\"\r\n        待处理的项目中移除\r\n        \"\"\"\r\n        with self.lock:\r\n            print(\"%s取出\" % self.name)\r\n            return self.items.popleft()\r\n\r\n\r\nclass Worker(Thread):\r\n    \"\"\"\r\n    work线程\r\n    \"\"\"\r\n\r\n    def __init__(self, name, func, in_queue, out_queue):\r\n        super().__init__()\r\n        self.name = name\r\n        self.func = func\r\n        self.in_queue = in_queue\r\n        self.out_queue = out_queue\r\n        self.polled_count = 0  # 调用次数\r\n        self.work_done = 0  # 完成次数\r\n        print(\"初始化线程：%s,待工作：%s,已完成：%s\" % (self.name, len(self.in_queue.items), len(self.out_queue.items)))\r\n\r\n    def run(self):\r\n        while True:\r\n            print(\"运行：%s,待工作：%s,已完成：%s\" % (self.name, len(self.in_queue.items), len(self.out_queue.items)))\r\n            self.polled_count += 1\r\n            try:\r\n                item = self.in_queue.get()\r\n            except IndexError:\r\n                sleep(0.01)\r\n            else:\r\n                result = self.func(item)\r\n                self.out_queue.put(result)\r\n                self.work_done += 1\r\n\r\n            if len(done_queue.items) >= 100:\r\n                processed = len(done_queue.items)\r\n                polled = sum(t.polled_count for t in threads)  # 总共的调用次数\r\n                print(\"完成：%s, 执行了：%s\" % (processed, polled))\r\n            else:\r\n                print(\"正在执行，完成了：==========%s==========个\" % len(done_queue.items))\r\n\r\n    def __str__(self):\r\n        return self.name\r\n\r\n\r\n# 四个双端队列\r\ndownload_queue = MyQueue(\"download_queue\")\r\nresize_queue = MyQueue(\"resize_queue\")\r\nupload_queue = MyQueue(\"upload_queue\")\r\ndone_queue = MyQueue(\"done_queue\")\r\n\r\n\r\ndef download(item):\r\n    print(\"执行下载\")\r\n\r\n\r\ndef resize(item):\r\n    print(\"执行改变尺寸\")\r\n\r\n\r\ndef upload(item):\r\n    print(\"执行上传\")\r\n\r\n\r\nthreads = [\r\n    Worker(\"下载\", download, download_queue, resize_queue),\r\n    Worker(\"调整尺寸\", resize, resize_queue, upload_queue),\r\n    Worker(\"上传\", upload, upload_queue, done_queue)\r\n]\r\n\r\nfor thread in threads:\r\n    thread.start()\r\n\r\nfor _ in range(100):\r\n    download_queue.put(object())\r\n\r\n```\r\n以上代码的缺陷\r\n\r\n1. 每个阶段的工作函数的执行速度可能都有差别，可能会使得前一段会拖慢后一阶段的进度，从而使整条管线迟滞\r\n2. 后一阶段的会在循环语句中。反复查询出入的队列，获取新的任务，而前一个又迟迟不把任务交过来，会白白浪费CPU时间\r\n3. 为了判断所有的任务是否已经执行完成了，必须再写一个循环，持续判断done_queue的任务数量\r\n4. worker线程的run方法会一直执行其循环，即使该停了 也灭有通知停止\r\n5. 如果管线的某个阶段发生迟滞，那么随时都可能发生程序崩溃。比如第一个阶段处理的很快，第二阶段处理的很慢，\r\nresize_queue队列就会不断增大，持续一段时间后，耗尽内存，进而崩溃\r\n\r\n### 改进\r\n```python\r\n\"\"\"\r\n@python 3.6\r\n\r\n- 管线是一种优秀的任务处理方式，它可以把处理流程划分为若干阶段，并使用多条线程来同时执行这些任务\r\n- 构建并发式的管线时，要注意：\r\n    1. 防止某个阶段陷入持续等待的状态之中\r\n    2. 如果停止工作线程\r\n    3. 如何防止内存膨胀\r\n- queue类所提供的机制 可以彻底解决上述问题，\r\n    1. 它具备阻塞时的队列操作，能够制定缓冲区大小\r\n    2. 还支持join方法\r\n\"\"\"\r\nfrom collections import deque\r\nfrom queue import Queue\r\nfrom threading import Lock, Thread\r\nfrom time import sleep\r\n\r\n\r\nclass ClosableQueue(Queue):\r\n    SENTINEL = object()\r\n\r\n    def close(self):\r\n        self.put(self.SENTINEL)\r\n        pass\r\n\r\n    def __iter__(self):\r\n        \"\"\"\r\n        定义迭代器，在迭代的时候如果发现特殊对象的时候会停止迭代\r\n        也会在适当的时候调用task_done是的可以追踪队列的工作进度\r\n        只要for循环耗尽，线程就会推出\r\n        :return:\r\n        \"\"\"\r\n        while True:\r\n            job = self.get()\r\n            try:\r\n                if job is self.SENTINEL:\r\n                    return\r\n                yield job\r\n            finally:\r\n                self.task_done()\r\n\r\n\r\nclass StoppableWorker(Thread):\r\n    def __init__(self, func, in_queue, out_queue):\r\n        super().__init__()\r\n        self.func = func\r\n        self.in_queue = in_queue\r\n        self.out_queue = out_queue\r\n\r\n    def run(self):\r\n        print(self.getName() + \"运行\")\r\n        for item in self.in_queue:\r\n            result = self.func(item)\r\n            self.out_queue.put(item)\r\n\r\n\r\ndownload_queue = ClosableQueue()\r\nresize_queue = ClosableQueue()\r\nupload_queue = ClosableQueue()\r\ndone_queue = ClosableQueue()\r\n\r\n\r\ndef download(item):\r\n    print(\"执行下载\")\r\n\r\n\r\ndef resize(item):\r\n    print(\"执行改变尺寸\")\r\n\r\n\r\ndef upload(item):\r\n    print(\"执行上传\")\r\n\r\n\r\nthreads = [\r\n    StoppableWorker(download, download_queue, resize_queue),\r\n    StoppableWorker(resize, resize_queue, upload_queue),\r\n    StoppableWorker(upload, upload_queue, done_queue)\r\n]\r\n\r\nfor thread in threads:\r\n    thread.start()\r\n\r\nfor _ in range(100):\r\n    download_queue.put(object())\r\n\r\ndownload_queue.close()  # 发出终止信号\r\ndownload_queue.join()\r\n\r\nresize_queue.close()\r\nresize_queue.join()\r\n\r\nupload_queue.close()\r\nupload_queue.join()\r\n\r\nprint(\"完成：%s\" % done_queue.qsize())\r\n\r\n```\r\n\r\n\r\n## 多进程','2019-08-21 07:12:50.000000','p','o','a',85,0,1,2),(41,'2019-08-22 04:01:39.682608','2019-08-22 04:01:39.682615','python协程','# python协程\r\n\r\n### 同步编程\r\n内存数据读写、磁盘寻道读写、网卡读写等操作都是 I/O 操作，\r\n同步程序的瓶颈在于漫长的 I/O 等待，想要提高程序效率必须减少 I/O 等待时间，从提高程序的局部性着手。\r\n\r\n同步编程的改进方式有多进程、多线程，但对于 c10k 问题都不是良好的解决方案，\r\n多进程的方式存在操作系统可调度进程数量上限较低，进程间上下文切换时间过长，进程间通信较为复杂\r\n\r\n### 异步编程\r\n说到异步非阻塞调用，目前的代名词都是 epoll 与 kqueue，select/poll 由于效率问题基本已被取代。\r\n\r\nepoll 是04年 Linux2.6 引入内核的一种 I/O 事件通知机制，它的作用是将大量的文件描述符托管给内核，\r\n内核将最底层的 I/O 状态变化封装成读写事件，这样就避免了由程序员去主动轮询状态变化的重复工作，\r\n程序员将回调函数注册到 epoll 的状态上，当检测到相对应文件描述符产生状态变化时，就进行函数回调。\r\n\r\n事件循环是异步编程的底层基石。\r\n\r\n1. 用户创建了两个socket连接，将系统返回的两个文件描述符fd3、fd4通过系统调用在epoll上注册读写事件；\r\n2. 当网卡解析到一个tcp包时，内核根据五元组找到相应到文件描述符，自动触发其对应的就绪事件状态，并将该文件描述符添加到就绪链表中。\r\n3. 程序调用epoll.poll()，返回可读写的事件集合。\r\n4. 对事件集合进行轮询，调用回调函数等。\r\n5. 一轮事件循环结束，循环往复\r\n\r\n这个繁琐的注册回调与回调的过程得以封装，并抽象成EventLoop。\r\nEventLoop屏蔽了进行epoll系统调用的具体操作。对于用户来说，将不同的I/O状态考量为事件的触发，只需关注更高层次下不同事件的回调行为。\r\n诸如libev, libevent之类的使用C编写的高性能异步事件库已经取代这部分琐碎的工作。\r\n\r\nEventLoop简化了不同平台上的事件处理，但是处理事件触发时的回调依然很麻烦，响应式的异步程序编写对程序员的心智是一项不小的麻烦。\r\n\r\n因此，协程被引入来替代回调以简化问题。协程模型主要在在以下方面优于回调模型。\r\n\r\n1. 以近似同步代码的编程模式取代异步回调模式，真实的业务逻辑往往是同步线性推演的，因此，这种同步式的代码写起来更加容易。底层的回调依然是callback hell，但这部分脏活累活已经转交给编译器与解释器去完成，程序员不易出错。\r\n2. 异常处理更加健全，可以复用语言内的错误处理机制，回调方式。而传统异步回调模式需要自己判定成功失败，错误处理行为复杂化。\r\n3. 上下文管理简单化，回调方式代码上下文管理严重依赖闭包，不同的回调函数之间相互耦合，割裂了相同的上下文处理逻辑。协程直接利用代码的执行位置来表示状态，而回调则是维护了一堆数据结构来处理状态。\r\n4. 方便处理并发行为，协程的开销成本很低，每一个协程仅有一个轻巧的用户态栈空间。\r\n\r\n根本的理念：用户态通过事件循环驱动实现调度\r\n\r\n## Gevent\r\n![](/media/editor/v2-49636e448c48d201d3c7e3d69c107dbf_r_20190822103724663269.jpg)\r\nGevent 基于 Greenlet 与 Libev，greenlet 是一种微线程或者协程，在调度粒度上比 PY3 的协程更大。\r\ngreenlet 存在于线程容器中，其行为类似线程，有自己独立的栈空间，不同的 greenlet 的切换类似操作系统层的线程切换。\r\n\r\ngreenlet.hub 也是一个继承于原生 greenlet 的对象，也是其他 greenlet 的父节点，它主要负责任务调度。\r\n当一个 greenlet 协程执行完部分例程后到达断点，通过 greenlet.switch() 向上转交控制权给 hub 对象，hub 执行上下文切换的操作：从寄存器、高速缓存中备份当前 greenlet 的栈内容到内存中，并将原来备份的另一个 greenlet 栈数据恢复到寄存器中。\r\n\r\nhub 对象内封装了一个 loop 对象，loop 负责封装 libev 的相关操作并向上提供接口，所有 greenlet 在通过 loop 驱动的 hub 下被调度\r\n\r\n\r\n## yield\r\n在 Python2.5 中生成器还加入了 send 方法，与 yield 搭配使用。\r\n我们发现，此时，生成器不仅仅可以 yield 暂停到一个状态，还可以往它停止的位置通过 send 方法传入一个值改变其状态。\r\n举一个简单的示例，主要熟悉 yield 与 send 与外界的交互流程\r\n\r\n```python\r\ndef jump_range(up_to):\r\n   step = 0\r\n   while step < up_to:\r\n     jump = yield step\r\n     print(\"jump\", jump)\r\n     if jump is None:\r\n         jump = 1\r\n         step += jump\r\n     print(\"step\", step)\r\n\r\nif __name__ == \'__main__\':\r\n   iterator = jump_range(10)\r\n   print(next(iterator))  # 0\r\n   print(iterator.send(4))  # jump4; step4; 4\r\n   print(next(iterator))  # jump None; step5; 5\r\n   print(iterator.send(-1)) # jump -1; step4; 4\r\n```\r\n\r\n在 Python3.3 中，生成器又引入了 yield from 关键字，yield from 实现了在生成器内调用另外生成器的功能，\r\n可以轻易的重构生成器，比如将多个生成器连接在一起执行。\r\n```python\r\ndef gen_3():\r\n   yield 3\r\n\r\ndef gen_234():\r\n   yield 2\r\n   yield from gen_3()\r\n   yield 4\r\n\r\ndef main():\r\n   yield 1\r\n   yield from gen_234()\r\n   yield 5\r\n\r\nfor element in main():\r\n   print(element)  # 1,2,3,4,5\r\n```','2019-08-22 03:49:22.000000','p','o','a',82,-1,1,2),(42,'2019-08-23 06:32:29.019943','2019-08-23 06:32:29.019949','python基础扫盲','针对不熟悉，用的少的api就行扫盲\r\n\r\n### 1. ord()和chr()\r\n字符和ascII码的转换\r\n\r\n### bin()、int()、oct()、hex()\r\n进制的转换 0b 0o 0x分别为：二进制、八进制、十六进制\r\n\r\n### 函数是值转递还是引用传递\r\n不可变参数用值传递，可变参数用引用传递。像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象\r\n\r\n### 字符串倒序\r\n\r\n```python\r\ndef string_reverse1(text=\'abcdef\'):\r\nreturn text[::-1]\r\n```\r\n\r\n### 类变量\r\n```python\r\n\r\nclass Parent(object):\r\n	x = 1\r\nclass Child1(Parent):\r\n	pass\r\nclass Child2(Parent):\r\n	pass\r\nprint Parent.x, Child1.x, Child2.x # 1,1,1 # \r\nChild1.x = 2\r\nprint Parent.x, Child1.x, Child2.x # 1，2，1\r\nParent.x = 3\r\nprint Parent.x, Child1.x, Child2.x # 3,2,3\r\n\r\n```\r\n第一个输出：\r\n在 Python中，类变量在内部是作为字典处理的。\r\n如果一个变量的名字没有在当前类的字典中发现，将搜索祖先类（比如父类）直到被引用的变量名被找到.\r\n\r\n第二个输出：它的子类重写了该值，该值仅仅在子类中被改变\r\n\r\n第三个输出：如果该值在父类中被改变（例如，我们执行语句 Parent.x = 3），这个改变会影响\r\n到任何未重写该值的子类当中的值（在这个示例中被影响的子类是 Child2）\r\n\r\n### 切片\r\n```python\r\nlist = [\'a\', \'b\', \'c\', \'d\', \'e\']\r\nprint(list[:20])\r\nprint(list[10:])\r\n# 这样都不会报错 不会导致IndexError\r\n\r\nlist[::-1]\r\n# 直接倒序\r\n\r\n```\r\n\r\n### 默认参数\r\n```python\r\n# 新的默认列表仅仅只在函数被定义时创建一次\r\ndef extendList(val, list=[]):\r\n    list.append(val)\r\n    return list\r\n\r\n\r\nlist1 = extendList(10)\r\nlist2 = extendList(123, [])\r\nlist3 = extendList(\'a\')\r\nprint(\"list1 = %s\" % list1)  # list1 = [10, \'a\']\r\nprint(\"list2 = %s\" % list2)  # list2 = [123]\r\nprint(\"list3 = %s\" % list3)  # list3 = [10, \'a\']\r\n\r\n# 所以，list1和list3没有指定list的时候，使用的是同一个列表\r\n# 这就是为什么当函数被定义的时候，表达式是用默认参数被计算，而不是它被调用的时候\r\n```\r\n\r\n### zip创建键值对\r\n\r\n```python\r\nkeys = [\'Name\', \'Sex\', \'Age\']\r\nvalues = [\'Jack\', \'Male\', 23]\r\ndict(zip(keys,values))\r\n```\r\n\r\n### 去重后，元素的排序改变了，想保持原来的排序\r\n```python\r\nlist_element = [\'a\',\'c,\',\'z\',\'x\',\'a\']      #此列表元素有重复\r\ndelete_element = list( set(list_element))     #利用集合的唯一性删除重复元素\r\ndelete_element.sort(key = list_element.index)   #对修改后的列表进行排序\r\nprint(\"原始列表为：\",list_element)\r\nprint(\"修改后的列表为：\",delete_element)\r\n```\r\n### dir()\r\n函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；\r\n带参数时，返回参数的属性、方法列表。如果参数包含方法__dir__()，该方法将被调用。\r\n如果参数不包含__dir__()，该方法将最大限度地收集参数信息。\r\n\r\n### 反斜杠\r\n与大多数编程语言相同，正则表达式里面使用“ \\ ”作为转义字符，这就可能造成反斜杠困扰\r\n，假如你需要匹配文本中的字符\'\' \\ \'\' 那么使用编程语言表示的正则表达式里面将需要4个反斜\r\n杠\"\\\\\\\\\",前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表\r\n达式里面转义成一个反斜杠，python里的原生字符串很好的解决了这个问题，这个例子中的正则\r\n表达式可以使用  r\"\\\\  表示。同样，匹配一个数字的\"\\\\d\"可以写成r\"\\d.有了原生字符串，你再\r\n也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。\r\n\r\n### with\r\n\r\n用于一些不管发布发生异常，资源都会自动处理的场景。比如读取文件，全局锁的释放。利用了__enter__和__exit__实现上下文管理器。\r\n\r\n### python的解释性\r\n\r\n解释性语言使用解释器将源码逐行解释成机器码并立即执行，不会进行整体的编译和链接处理，相当于把编译性语言中的编译和解释混合到了一起执行。\r\n\r\n\r\n### Ipython\r\n\r\n对于cpython默认的shell，支持自动补全\r\n\r\n```bash\r\npip install ipython\r\n```\r\n\r\n### python3对比python2的改进\r\n- python的除法\r\n- super()不用传self\r\n- python文件不用再声明utf-8编码\r\n- 解包\r\n- 对异常的处理，异常都会放入栈中，方便调试应用\r\n- 一切都返回迭代器\r\n- 移除xrange\r\n- 新增yield from链接生成器\r\n- 对urllib、select、dict的优化\r\n- 内置asyncio，原生协程支持异步编程\r\n- 新增内置库，asyncio、address、enum、current.future\r\n- pyc统一移动到__cache__中\r\n通过six模块兼容2和3的语法、或者使用2->3的工具转换、__future__\r\n\r\n### python不可变类型\r\n\r\nint string bool float tuple frozenset\r\n\r\n###','2019-08-23 06:26:50.000000','p','o','a',85,0,1,2),(43,'2019-08-24 04:20:54.184609','2019-08-24 04:20:54.184616','链表反转','## leetcode 92\r\n```python\r\n# 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。\r\n#\r\n# 说明:\r\n# 1 ≤ m ≤ n ≤ 链表长度。\r\n#\r\n# 示例:\r\n#\r\n# 输入: 1->2->3->4->5->NULL, m = 2, n = 4\r\n# 输出: 1->4->3->2->5->NULL\r\n\r\n# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, x):\r\n        self.val = x\r\n        self.next = None\r\n\r\n    def __str__(self):\r\n        return self.val\r\n\r\n\r\nclass Solution:\r\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode or None:\r\n        if not head:\r\n            return None\r\n        cur, pre = head, None\r\n        while m > 1:\r\n            pre = cur\r\n            cur = cur.next\r\n            m -= 1\r\n            n -= 1\r\n        print_linkedList(cur)\r\n\r\n        tail, start = cur, pre\r\n\r\n        while n:\r\n            tmp = cur.next\r\n            cur.next = pre\r\n            pre = cur\r\n            cur = tmp\r\n            n -= 1\r\n\r\n        if start:\r\n            start.next = pre\r\n        else:\r\n            head = pre\r\n        tail.next = cur\r\n        return head\r\n\r\ndef print_linkedList(head: ListNode):\r\n    arr = []\r\n    while head:\r\n        arr.append(head.val)\r\n        head = head.next\r\n    print(arr)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    node_list = []\r\n    arr = [1, 2, 3, 4, 5, 6]\r\n    for a in arr:\r\n        node = ListNode(a)\r\n        node_list.append(node)\r\n\r\n    n = len(node_list)\r\n    for index, node in enumerate(node_list):\r\n        if index + 1 < n:\r\n            node.next = node_list[index + 1]\r\n        else:\r\n            node.next = None\r\n\r\n    head = node_list[0]\r\n    # print_linkedList(head)\r\n    new_head = Solution().reverseBetween(head, 2, 5)\r\n    print_linkedList(new_head)\r\n\r\n```','2019-08-24 04:19:53.000000','p','o','a',81,0,1,2),(44,'2019-08-24 12:02:39.546003','2019-08-24 12:02:39.546010','python内置的队列','# python内置的队列\r\n\r\nPython标准库包含了四种队列\r\n- collections.deque\r\n- queue.Queue\r\n- asyncio.Queue\r\n- multiprocessing.Queue\r\n\r\n## Collections.deque\r\n双端队列 double ended queue\r\n方法：\r\n- rotate\r\n- 其他的就不列举了\r\n\r\n都是原子操作，是线程安全的方法，并且有很高的性能\r\n\r\n## queue.Queue & asyncio.Queue\r\n\r\n相同点：\r\n- 都是基于collections.deque\r\n- 都是支持多生产者、多消费者的队列\r\n- 都提供了Queue（FIFO队列）、PriorityQueue（优先级队列）、LifoQueue（LIFO队列），接口方面也相同\r\n\r\n\r\n不同点：\r\n- queue.Queue适用于多线程的场景，asyncio.Queue适用于协程场景下的通信\r\n- 由于asyncio的加成，queue.Queue下的阻塞接口在asyncio.Queue中则是以返回协程对象的方式执行\r\n- 前者同步队列，后者异步队列\r\n- 前者线程安全，后者线程不安全\r\n- 超时机制，前者通过timeout参数设定，后者通过asyncio.wait_for方法实现\r\n- qsize(),前者是预估的队列长度，后者因为是单线程，所以是准确的\r\n\r\n## multiprocessing.Queue\r\n\r\nmultiprocessing提供了三种队列\r\n- Queue\r\n- SimpleQueue\r\n- JoinableQueue。\r\n\r\nmultiprocessing.Queue既是线程安全也是进程安全的，相当于queue.Queue的多进程克隆版。和threading.Queue很像，multiprocessing.Queue支持put和get操作，底层结构是multiprocessing.Pipe。\r\n\r\nmultiprocessing.Queue底层是基于Pipe构建的，但是数据传递时并不是直接写入Pipe，而是写入进程本地buffer，通过一个feeder线程写入底层Pipe，这样做是为了实现超时控制和非阻塞put/get，所以Queue提供了join_thread、cancel_join_thread、close函数来控制feeder的行为，close函数用来关闭feeder线程、join_thread用来join feeder线程，cancel_join_thread用来在控制在进程退出时，不自动join feeder线程，使用cancel_join_thread有可能导致部分数据没有被feeder写入Pipe而导致的数据丢失。\r\n\r\n和threading.Queue不同的是，multiprocessing.Queue默认不支持join()和task_done操作，这两个支持需要使用mp.JoinableQueue对象。\r\n\r\nSimpleQueue是一个简化的队列，去掉了Queue中的buffer，没有了使用Queue可能出现的问题，但是put和get方法都是阻塞的并且没有超时控制。\r\n\r\n\r\n\r\n## 总结\r\n\r\n通过对比可以发现，上述四种结构都实现了队列，但是用处却各有偏重，\r\ncollections.deque在数据结构层面实现了队列，但是并没有应用场景方面的支持，可以看做是一个基础的数据结构。\r\nqueue模块实现了面向多线程的队列，\r\nasyncio.queue模块则实现了协程的队列，\r\nmultiprocessing.queue模块实现了面向多进程的队列。','2019-08-24 11:38:12.000000','p','o','a',74,0,1,2),(45,'2019-09-01 09:52:35.923625','2019-09-01 09:52:35.923634','python面试','# 面试\r\n\r\n面试了一家线上教育平台的公司， 存在的一些问题\r\n\r\n1. event loop细节\r\n2. 最大堆的代码实现\r\n3. python3对python2的改进\r\n4. redis发布订阅的细节\r\n5. socket初始化的过程\r\n6. mysql的索引、连接。一段sql查询特别卡怎么办\r\n7. python3 order dict排序是怎么实现的\r\n8. 多线程、多进程、协程\r\n9. 项目中的细节：服务挂了怎么办 redis挂了怎么办 同时修改金币的问题\r\n\r\n问了好多问题，基础太差了。这几天恶补了一下mysql原理。\r\n整理完mysql的文章，就把这些问题一个个解决。\r\n办法总比困难多。:muscle:\r\n\r\n## event loop\r\n\r\n### javascript\r\nhttps://juejin.im/post/5c3d8956e51d4511dc72c200\r\n\r\n当然面试问的不是上面这个，是Python的事件驱动编程','2019-09-01 09:46:57.000000','p','o','a',64,0,1,2),(46,'2019-09-01 13:17:15.202993','2019-09-01 13:17:15.202998','九月二号','## 九月二号\r\n\r\n上周开始投的简历，就去了一家面试，三家都没去，有点不敢去，针对这家提的多的问题用了四天把mysql原理简单过了一遍。\r\n\r\n从云腾实习结束开始，才学的php做的毕业设计,接着内推才找到的工作，做了一年的java开发和h5 app。\r\n来深圳之后，因为唐哥的人格魅力等种种因素开始做棋牌。\r\n一年半，大部分精力都放上面了。也没有太注重职业规划、底层知识结构。\r\n导致现在的路针对**岗位**来讲越走越窄。\r\n\r\n- web前端:css不怎么样，js还行，页面要做出美感来很难受。\r\n- java后端：都一年多没搞了，本身也不适合平常自己做项目\r\n- laya客户端开发：工作岗位偏少 还总是加班\r\n\r\n还记得第二个面试官的那句话：对于一个工科学生的2年经验来说，还是差了点。\r\n不管是真话还是好意，或多或少我心里是很安慰的。\r\n\r\n这两年都是什么技术新，我学什么，也是为了解决一些痛点或者说让自己更舒服点才去学的。\r\n- 从jq学到vue、node（数据驱动：不用自己更新状态了，管好数据就行。组件化：复用、统一、维护性强、扩展强）。\r\n- 之前搞spring的时候，还学了点spring boot（对ssh或者ssm来讲，配置方便，也是当时菜，配置配不来。）。\r\n- 搞laya的时候，又去学了Typescript（都是js写的，弱类型的实在是难受，继承和接口js写起来看的也难受）。\r\n- 搞服务器的时候，我又去学了docker（服务器光php就三个版本，还有各种服务，老受影响，服务器还老换，每次都要重新装环境）。\r\n- 搞flask的时候，去学了django（flask真的是很考验代码组织能力。可能一下放纵，代码就乱了。django本身带了管理后台，用了rest和序列化，开发更快）\r\n- 自己喜欢爬虫，因为收集一些数据对我来讲很有吸引力。然后又自己学了点scrapy和mongodb。\r\n......\r\n\r\n\r\n\r\n学了这些对我找工作也没什么影响，人家问你vue的实现原理，除了说几个关键字，也讲不来，平常工作还看不上这些源码。\r\nts、spring一系列的东西，除了吸收里面的一些思想，对工作也用不到。\r\ndocker、scrapy、mongodb、django，对于工作的层面上，在这些领域的知识又不够。\r\n\r\n所以有了我现在的焦虑。。。。\r\n\r\n总的来讲，我还是更喜欢python，也更擅长Python。就这样python一条路走到黑。把基础知识都补回来。\r\n\r\n- 数据结构和算法\r\n- 计算机网络\r\n- 操作系统\r\n\r\n\r\n压力总是在，习惯吧。\r\n\r\n\r\n明天生日:smirk:\r\n\r\n睡觉:sleepy:\r\n\r\n9.25 更新一下\r\n\r\n上班十多天，薪资还行把 离得也近 双休 就答应了','2019-09-01 11:59:32.000000','p','o','a',70,0,1,1),(47,'2019-09-02 03:10:51.283402','2019-09-02 03:10:51.283411','flask','# flask源码学习\r\n\r\n没有分析的详细过程，只做个大概的记录。\r\n\r\n## UWSGI\r\nWSGI，全称 Web Server Gateway Interface，或者 Python Web Server Gateway Interface ，\r\n是基于 Python 定义的 Web 服务器和 Web 应用程序或框架之间的一种简单而通用的接口。\r\nWSGI接口的作用是确保HTTP请求能够转化成python应用的一个功能调用，\r\n这也就是Gateway的意义所在，网关的作用就是在协议之前进行转换。\r\n\r\nWSGI接口中有一个非常明确的标准，\r\n每个Python Web应用必须是可调用callable的对象且返回一个iterator，\r\n并实现了app(environ, start_response) 的接口，\r\nserver 会调用 application，\r\n并传给它两个参数：environ 包含了请求的所有信息，\r\nstart_response 是 application 处理完之后需要调用的函数，参数是状态码、响应头部还有错误信息。\r\n\r\nflask的核心组件有两个Jinjia2和werkzeug\r\nJinjia2: \r\n> 是一个基于python实现的模板引擎，提供对于HTML的页面解释，当然它的功能非常丰富，\r\n可以结合过滤器、集成、变量、流程逻辑支持等作出非常简单又很酷炫的的web出来。\r\nFlask类实例运行会创造一个Jinjia的环境\r\n\r\nwerkzeug:\r\n>  HTTP 和 WSGI 相关的工具集，可以用来编写 web 框架，也可以直接使用它提供的一些帮助函数\r\n\r\n## 一个请求的过程\r\n这里，我们通过追踪一个请求到达服务器并返回（当然是通过“变成”一个相应）的旅程，串讲本文的内容。\r\n\r\n在请求发出之前，Flask 注册好了所有的视图函数和 URL 映射，服务器在自己身上注册了 Flask 应用。\r\n请求到达服务器，服务器准备好 environ 和 make_response 函数，然后调用了自己身上注册的 Flask 应用。\r\n应用实现了 WSGI 要求的 application(environ, make_response) 方法。在 Flask 中，这个方法是个被 __call__ 中转的叫做 wsgi_app 的方法。它首先通过 environ 创建了请求上下文，并将它推入栈，使得 flask 在处理当前请求的过程中都可以访问到这个请求上下文。\r\n然后 Flask 开始处理这个请求，依次调用 before_first_request_funcs before_request_funcs view_functions 中的函数，并最终通过 finalize_request 生成一个 response 对象，当中只要有函数返回值，后面的函数组就不会再执行，after_request_funcs 进行 response 生成后的后处理。\r\nFlask 调用这个 response 对象，最终调用了 make_response 函数，并返回了一个可遍历的响应内容。\r\n服务器发送响应。\r\n\r\n## Flask 和 werkzeug\r\n在分析过程中，可以很明显地看出 Flask 和 werkzeug 是强耦合的，实际上 werkzeug 是 Flask 唯一不可或缺的依赖，一些非常细节的工作，其实都是 werkzeug 库完成的，在本文的例子中，它至少做了这些事情：\r\n\r\n封装 Response 和 Request 类型供 Flask 使用，在实际开发中，我们在请求和响应对象上的操作，调用的其实是 werkzeug 的方法。\r\n实现 URL 到视图函数的映射，并且能把 URL 中的参数传给该视图函数。我们看到了 Flask 的 url_map 属性并且看到了它如何绑定视图函数和错误处理函数，但是具体的映射规则的实践，和在响应过程中的 URL 解析，都是由 werkzeug 完成的。\r\n通过 LocalProxy 类生成的 _request_ctx_stack 对 Flask 实现线程保护。\r\n\r\n对于 Flask 的源码分析先暂时到这里。有时间的话，我会分析 Flask 中的模板渲染、import request、蓝图和一些好用的变量及函数，或者深入分析 werkzeug 库。\r\n\r\n\r\n## flask上下文\r\nhttps://cizixs.com/2017/01/13/flask-insight-context/','2019-09-02 01:19:55.000000','p','o','a',92,0,1,2),(48,'2019-09-04 11:12:14.799944','2019-09-04 11:12:14.799950','leetcode 冒泡排序和常见排序','给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。\r\n\r\n如果不能形成任何面积不为零的三角形，返回 0。\r\n\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def largestPerimeter(self, A: List[int]) -> int:\r\n        if len(A) < 3:\r\n            return 0\r\n        A.sort()\r\n\r\n        n = len(A)\r\n        index = n - 3\r\n        while index >= 0:\r\n            arr = A[index: index + 3]\r\n            # 检查能不能构成三件型\r\n            if arr[0] + arr[1] > arr[2]:\r\n                # 能构成三角形\r\n                return sum(arr)\r\n            else:\r\n                index -= 1\r\n\r\n        return 0\r\n```\r\n 使用冒泡排序最好， 拍了三轮 就去比 不能形成再拍一轮\r\n \r\n ```python\r\n class Solution:\r\n    def largestPerimeter(self, A: List[int]) -> int:\r\n        n = len(A)\r\n        for i in range(n):\r\n            for j in range(n - i - 1):\r\n                if A[j] > A[j + 1]:\r\n                    A[j], A[j + 1] = A[j + 1], A[j],\r\n\r\n            if i >= 2:\r\n                arr = A[-i - 1:][:3]\r\n                if arr[0] + arr[1] > arr[2]:\r\n                    return sum(arr)\r\n\r\n        return 0\r\n ```\r\n占用空间小了，但是执行时间还长了.......跟想象中不一样\r\n\r\n下面是使用冒泡的\r\n![](/media/editor/微信截图_20190905001153_20190904111114220867.png)\r\n\r\n## 其他排序\r\n```python\r\nimport random\r\n\r\n\r\ndef pao_sorted(arr):\r\n    \"\"\"\r\n    冒泡排序：\r\n    最大值向右边冒泡\r\n    外层循环递减\r\n    :param arr:\r\n    :return:\r\n    \"\"\"\r\n    # 外层控制单词交换的次数\r\n    for i in range(len(arr) - 1, 0, -1):\r\n        # 内层控制交换的位置\r\n        for j in range(i):\r\n            if arr[j] > arr[j + 1]:\r\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\r\n            print(arr)\r\n    return arr\r\n\r\n\r\ndef min_sorted(arr):\r\n    \"\"\"\r\n    选择排序:\r\n    每次循环 拿到最小 从左到右 依次排列\r\n    :param arr:\r\n    :return:\r\n    \"\"\"\r\n    for i in range(len(arr)):\r\n        min_num = arr[i]\r\n        min_index = i\r\n        # 循环取这次最小的\r\n        for j in range(i, len(arr)):\r\n            if arr[j] < min_num:\r\n                min_num = arr[j]\r\n                min_index = j\r\n        print(\"外层循环到了：%s，此时最小是：%s,在位置：%s,\" % (i, min_num, min_index))\r\n        if min_index > i:\r\n            arr[i], arr[min_index] = arr[min_index], arr[i]\r\n        print(\"交换后：%s\" % arr)\r\n    return arr\r\n\r\n\r\ndef quick_sort(arr):\r\n    \"\"\"\r\n    快速排序\r\n    分而治之 递归调用\r\n    :param arr:\r\n    :return:\r\n    \"\"\"\r\n    # 出口:少于1直接返回\r\n    if len(arr) > 1:\r\n        mid = arr[len(arr) // 2]\r\n        arr.remove(mid)\r\n        left = []\r\n        right = []\r\n        for item in arr:\r\n            if item < mid:\r\n                left.append(item)\r\n            else:\r\n                right.append(item)\r\n        return quick_sort(left) + [mid] + quick_sort(right)\r\n    else:\r\n        return arr\r\n\r\n\r\ndef insert_sort(arr):\r\n    \"\"\"\r\n    插入排序：\r\n    它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入\r\n    :param arr:\r\n    :return:\r\n    \"\"\"\r\n    for i in range(1, len(arr)):\r\n        pre_index = i - 1\r\n        cur = arr[i]\r\n        while pre_index >= 0 and arr[pre_index] > cur:\r\n            arr[pre_index + 1] = arr[pre_index]\r\n            pre_index -= 1\r\n\r\n        arr[pre_index + 1] = cur\r\n\r\n    return arr\r\n\r\n\r\ndef merge_sort(arr):\r\n    \"\"\"\r\n    归并排序\r\n    把长度为n的输入序列分成两个长度为n/2的子序列；\r\n    对这两个子序列分别采用归并排序；\r\n    将两个排序好的子序列合并成一个最终的排序序列。\r\n    :param arr:\r\n    :return:\r\n    \"\"\"\r\n    if len(arr) < 2:\r\n        return arr\r\n\r\n    mid = len(arr) // 2\r\n    left = merge_sort(arr[:mid])\r\n    right = merge_sort(arr[mid:])\r\n    return merge(left, right)\r\n\r\n\r\ndef merge(left, right):\r\n    \"\"\"\r\n    用于归并排序的一个方法\r\n    :param left:\r\n    :param right:\r\n    :return:\r\n    \"\"\"\r\n    res = []\r\n    while left and right:\r\n        if left[0] < right[0]:\r\n            res.append(left.pop(0))\r\n        else:\r\n            res.append(right.pop(0))\r\n    res.extend(left or right)\r\n    return res\r\n\r\n\r\nclass MaxHeap:\r\n\r\n    def __init__(self, arr):\r\n        self.data = arr\r\n        for i in range(len(self.data) // 2, -1, -1):\r\n            self.heapify(i)\r\n\r\n    def heapify(self, index):\r\n        \"\"\"\r\n         堆调整\r\n        :param index:\r\n        :return:\r\n        \"\"\"\r\n        left = 2 * index + 1\r\n        right = 2 * index + 2\r\n        max_index = index\r\n\r\n        if left < len(self.data) and self.data[left] > self.data[max_index]:\r\n            max_index = left\r\n\r\n        if right < len(self.data) and self.data[right] > self.data[max_index]:\r\n            max_index = right\r\n\r\n        if max_index != index:\r\n            # 交换\r\n            print(\"交换：%s <=====>  %s\" % (index, max_index))\r\n            self.data[index], self.data[max_index] = self.data[max_index], self.data[index]\r\n            self.heapify(max_index)\r\n\r\nif __name__ == \"__main__\":\r\n    arr = [i for i in range(30)]\r\n    random.shuffle(arr)\r\n    # ar = pao_sorted(arr)# 冒泡排序\r\n    # ar = min_sorted(arr)  # 选择排序\r\n    # ar = quick_sort(arr)  # 快速排序\r\n    # ar = insert_sort(arr)  # 插入排序\r\n    # ar = merge_sort(arr)  # 归并排序\r\n    # print(ar)\r\n\r\n    heap = MaxHeap(arr)  # 堆排序\r\n    print(heap)\r\n\r\n\r\n```','2019-09-04 10:38:59.000000','p','o','a',79,0,1,2),(49,'2019-09-04 11:41:48.503231','2019-09-04 11:41:48.503237','罗湖面经过程','是去的第三次面试，本来想着太远了，不去了，hr喊了两次了，去试试水吧，顺便出去走走，哪知道比我想象中的远，一个半小时\r\n\r\n## 笔试\r\n\r\n1. 位置参数、默认参数、可变参数、关键字参数、和命名关键字参数、以及各种参数调用的组合\r\n2. js闭包和常用操作\r\n3. js手写快速排序\r\n4. python类变量\r\n5. 单表sql去重（去掉a,c都相同的字段）\r\n6. python手写一个装饰器，传入x为执行时间 当执行时间小于这个值时，print True\r\n7. lambda和map、filter\r\n8. 最后一题都没看，45分钟到了就没看题目了，傻逼了，因为有些题目好做的，但是手写不出。心态没调整好，做题目的时候就想着放弃了\r\n\r\n\r\n## 面试\r\n\r\n技术面试的话就项目上的问题问的比较多，还有框架。数据库没问，redis也没问，网络协议也没问，数据结构这些也没问,笔试差的原因肯定是\r\n\r\nhr面试的话，走了一个大部分公司都有的过场，介绍一些工作经历，项目，个人心态\r\n\r\n习惯了面向百度编程，还是代码敲少了。。。概念模糊\r\n一家做机顶盒游戏的，按月付费的\r\n\r\n总的来说心态变好了很多，没有之前那么方了，明天坂田面试，后天akulaku。多刷点题目。然后把这几天看的知识点再过一遍。总结一下。:punch:\r\n\r\n\r\n## 笔试题目的补充\r\n\r\n### 针对4\r\n```python\r\nclass A(object):\r\n    x = 1\r\n\r\nclass B(A):\r\n    pass\r\n\r\nclass C(A):\r\n    pass\r\n\r\n\r\nprint(A.x, B.x, C.x)  # 1 1 1\r\n\r\nB.x = 2\r\nprint(A.x, B.x, C.x)  # 1 2 1\r\n\r\nA.x = 3\r\nprint(A.x, B.x, C.x)  # 3 2 3\r\n\r\n# 在 Python 中，类变量在内部是作为字典处理的。如果一个变量的名字没有在当前类的字典中发现，将搜索祖先类（比如父类）直到被引用的变量名被找到（如果这个被引用的变量名既没有在自己所在的类又没有在祖先类中找到，会引发一个 AttributeError 异常 ）。\r\n#\r\n# 因此，在父类中设置 x = 1 会使得类变量 X 在引用该类和其任何子类中的值为 1。这就是因为第一个 print 语句的输出是 1 1 1。\r\n#\r\n# 随后，如果任何它的子类重写了该值（例如，我们执行语句 Child1.x = 2），然后，该值仅仅在子类中被改变。这就是为什么第二个 print 语句的输出是 1 2 1。\r\n#\r\n# 最后，如果该值在父类中被改变（例如，我们执行语句 Parent.x = 3），这个改变会影响到任何未重写该值的子类当中的值（在这个示例中被影响的子类是 Child2）。这就是为什么第三个 print 输出是 3 2 3。\r\n\r\n```\r\n\r\n### 针对6\r\n```python\r\n# 写一个装饰器，传入x为执行时间 当执行时间小于这个值时，print True\r\nimport time\r\n\r\n\r\nclass ShowTime(object):\r\n\r\n    def __init__(self, x):\r\n        self.x = x\r\n\r\n    def __call__(self, func, *args, **kwargs):\r\n        def wrapper(*inner_args, **inner_kwargs):\r\n            start_time = time.time()\r\n            func(*inner_args, **inner_kwargs)\r\n            end_time = time.time()\r\n            print(\"执行时间为，{0}\".format(end_time - start_time))\r\n            print(True if self.x > end_time - start_time else False)\r\n\r\n        return wrapper\r\n\r\n\r\n@ShowTime(5)\r\ndef demo(x, y):\r\n    print(\"========exec  start....\")\r\n    time.sleep(4)\r\n    print(x + y)\r\n    print(\"========exec  end....\")\r\n\r\n\r\ndemo(1, 3)\r\n\r\n```\r\n\r\n### 针对2\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n</head>\r\n<body onload=\"init()\">\r\n<p>段落1</p>\r\n<p>段落2</p>\r\n<p>段落3</p>\r\n<p>段落4</p>\r\n<p>段落5</p>\r\n</body>\r\n\r\n<script>\r\n    // 当点击p的时候 什么反应 为什么 \r\n    function init() {\r\n        var arr = document.getElementsByTagName(\"p\");\r\n        console.log(arr);\r\n        for (var i = 0; i < 5; i++) {\r\n            var node = arr[i];\r\n            // i = 8\r\n            node.onclick = function () {\r\n                alert(i)\r\n            }\r\n        }\r\n    }\r\n</script>\r\n</html>\r\n\r\n// 弹出5 \r\n```\r\n\r\n### 针对1\r\n```python\r\ndef test(a, b, c=2, d=2, *args, **kwargs):\r\n    print(a)\r\n    print(b)\r\n    print(c)\r\n    print(d)\r\n    print(args)\r\n    print(kwargs)\r\n\r\n\r\n# test(1, 2, )\r\n# test(1, 2)\r\n\r\n# test((1, 2,))\r\n\r\n# test(1)\r\n# test(11, 2, )\r\n# test(**{\'b\': 2, \'c\': 3, \'a\': \'123\'})\r\n\r\ntest(*[1, 2, 3, 4, ])\r\n# test(*[1, 2, 3, 4, 5])\r\n# test([1, 2, 3, 4, 5])  # 报错\r\n\r\n# test(([1, 2, 3, 4, 5]))  # 报错\r\n\r\n# test(*(1, 2, 3, 4, 5))\r\n# test(*(1, 2, 3, 4, 5,))\r\n\r\n\r\n```\r\n\r\n### 快速排序\r\npython\r\n```python\r\ndef quick_sort(arr):\r\n    if len(arr) >= 2:\r\n        mid = arr[len(arr) // 2]\r\n        left, right = [], []\r\n        arr.remove(mid)\r\n        for item in arr:\r\n            if item >= mid:\r\n                right.append(item)\r\n            else:\r\n                left.append(item)\r\n\r\n        return quick_sort(left) + [mid] + quick_sort(right)\r\n\r\n    return arr\r\n\r\n\r\narr = [i for i in range(100)]\r\nimport random\r\n\r\nrandom.shuffle(arr)\r\na = quick_sort(arr)\r\nprint(a)\r\n```\r\n\r\njs版本的快速排序，晚点写','2019-09-04 11:16:49.000000','p','o','a',87,0,1,2),(50,'2019-09-04 12:16:45.976406','2019-09-04 12:16:45.976411','TODOLIST','# 一直置顶的TODOLIST\r\n\r\n1. 把看的mysql原理再过一遍，尽量用自己的语言整理一遍出来。\r\n2. 还有多路复用\r\n3. 网络编程、socket\r\n4. 还有这两天看的视频的知识点也整理出来\r\n5. js的eventloop\r\n6. es6的再过一遍\r\n\r\n\r\n这几天从0开始搭了一个websocket连接。一下感觉对websocket socket socket.io的区别有了很深的印象 有空了整理出来','2019-09-04 12:13:15.000000','p','o','a',97,1,1,1),(51,'2019-09-05 03:45:47.345729','2019-09-05 03:45:47.345735','leetcode 指定面积最趋近于一个正方形','```python\r\nfrom typing import *\r\nimport cmath\r\n\r\nclass Solution:\r\n    def constructRectangle(self, area: int) -> List[int]:\r\n        short = 1\r\n        min_tmp = area\r\n        min_short = 1\r\n        sq = int(cmath.sqrt(area).real)\r\n        while short <= sq:\r\n            if area % short == 0:\r\n                long = area / short\r\n                if long - area / short <= min_tmp:\r\n                    min_tmp = long - area / short\r\n                    min_short = short\r\n            short += 1\r\n\r\n        return [int(area / min_short), int(min_short)]\r\n```','2019-09-05 03:44:40.000000','p','o','a',93,0,1,2),(52,'2019-09-05 05:26:10.861874','2019-09-05 05:26:10.861880','leetcode 返回质数的个数（厄拉多塞筛法）','用pythonic的写法 执行速度相差这么多\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def countPrimes(self, n: int) -> int:\r\n        if n < 2:\r\n            return 0\r\n        isPrimes = [1] * n\r\n        isPrimes[0] = isPrimes[1] = 0\r\n        for i in range(2, int(n ** 0.5) + 1):\r\n            if isPrimes[i] == 1:  # 如果没有检测过\r\n                for j in range(i * i, n, i):  # 以这个没有检测过的作为基数跳着赋值\r\n                    isPrimes[j] = 0\r\n                # 这种写法有点不好理解 \r\n                # isPrimes[i * i: n: i] = [0] * len(isPrimes[i * i: n: i])\r\n\r\n        return sum(isPrimes)\r\n\r\n\r\nSolution().countPrimes(10)\r\n\r\n\r\n```\r\n上面这种是用的 #isPrimes[i * i: n: i] = [0] * len(isPrimes[i * i: n: i])写法 \r\n![](/media/editor/微信截图_20190905182607_20190905052519955320.png)','2019-09-05 05:23:36.000000','p','o','a',94,0,1,2),(53,'2019-09-05 08:41:13.601327','2019-09-05 08:41:13.601336','leetcode 递归带货，深度优先','leetcode:第17题，难度中等。\r\n\r\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。（和手机键盘一样）\r\n\r\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\r\n\r\n```python\r\nfrom typing import List\r\n\r\n# 输入：\"23\"\r\n# 输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\r\n\r\nclass Solution:\r\n    def letterCombinations(self, digits: str) -> List[str]:\r\n        res = []\r\n        abc_dict = {\r\n            \'2\': \"abc\",\r\n            \'3\': \"def\",\r\n            \'4\': \"ghj\",\r\n            \'5\': \"klm\",\r\n            \'6\': \"nop\",\r\n            \'7\': \"qrs\",\r\n            \'8\': \"tuv\",\r\n            \'9\': \"wxyz\",\r\n        }\r\n\r\n        def inner(strs, index, c):\r\n            if len(strs) == index:\r\n                res.append(c)\r\n                return\r\n\r\n            s = strs[index]\r\n            a_c = abc_dict[s]\r\n            for a in a_c:\r\n                inner(strs, index + 1, c + a)\r\n\r\n        inner(digits, 0, \"\")\r\n\r\n        return res\r\n\r\n\r\na = Solution().letterCombinations(\"23\")\r\nprint(a)\r\n\r\n```','2019-09-05 08:39:25.000000','p','o','a',94,0,1,2),(54,'2019-09-05 09:23:55.283795','2019-09-05 09:23:55.283802','leetcode nim游戏','你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。\r\n\r\n你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。\r\n\r\n```python\r\n# 一开始没想明白\r\n\r\n# 让我们考虑一些小例子。显而易见的是，如果石头堆中只有一块、两块、或是三块石头，那么在你的回合，你就可以把全部石子拿走，从而在游戏中取胜。而如果就像题目描述那样，堆中恰好有四块石头，你就会失败。因为在这种情况下不管你取走多少石头，总会为你的对手留下几块，使得他可以在游戏中打败你。因此，要想获胜，在你的回合中，必须避免石头堆中的石子数为 4 的情况。\r\n\r\n# 同样地，如果有五块、六块、或是七块石头，你可以控制自己拿取的石头数，总是恰好给你的对手留下四块石头，使他输掉这场比赛。但是如果石头堆里有八块石头，你就不可避免地会输掉，因为不管你从一堆石头中挑出一块、两块还是三块，你的对手都可以选择三块、两块或一块，以确保在再一次轮到你的时候，你会面对四块石头。\r\n\r\n# 显然，它以相同的模式不断重复 n=4,8,12,16,\\dotsn=4,8,12,16,…，基本可以看出是 44 的倍数。\r\n\r\nclass Solution:\r\n    def canWinNim(self, n: int) -> bool:\r\n        return n % 4 != 0\r\n\r\n```','2019-09-05 09:21:22.000000','p','o','a',89,0,1,2),(55,'2019-09-05 10:42:41.241473','2019-09-05 10:42:41.241478','leetcode 二叉搜索树','题目：\r\n![](/media/editor/微信截图_20190905234222_20190905104138336464.png)\r\n\r\n\r\n## 利用二叉搜索树的特性\r\n\r\n```python\r\n# Definition for a binary tree node.\r\nclass TreeNode:\r\n    def __init__(self, x):\r\n        self.val = x\r\n        self.left = None\r\n        self.right = None\r\n\r\n\r\nclass Solution:\r\n    def lowestCommonAncestor(self, root: \'TreeNode\', p: \'TreeNode\', q: \'TreeNode\') -> \'TreeNode\':\r\n        if not root:\r\n            return None\r\n		# p、q各在一边的时候，直接返回root\r\n        if (p.val - root.val) * (q.val - root.val) >= 0:\r\n            return root\r\n        elif p.val > root.val and q.val > root.val:\r\n            return self.lowestCommonAncestor(root.right, p, q)\r\n        else:\r\n            return self.lowestCommonAncestor(root.left, p, q)\r\n\r\n```','2019-09-05 10:41:04.000000','p','o','a',88,0,1,2),(56,'2019-09-05 11:08:37.443416','2019-09-05 11:08:37.443423','leetcode 拼接链表','按照从小到大的顺序，拼接两个有序的链表l1和l2\r\n\r\n```python\r\nclass Solution:\r\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\r\n        tmp = ListNode(0)\r\n\r\n        # 如果不加这个 返回的就是最后的一个节点\r\n        res = tmp\r\n\r\n        if not l1:\r\n            return l2\r\n        if not l2:\r\n            return l1\r\n        while l1 and l2:\r\n            if l1.val <= l2.val:\r\n                tmp.next = l1\r\n                l1 = l1.next\r\n            else:\r\n                tmp.next = l2\r\n                l2 = l2.next\r\n            # 每次拼接也要往后移\r\n            tmp = tmp.next\r\n\r\n        # 拼接剩下的节点\r\n        tmp.next = l1 or l2\r\n\r\n        return res.next\r\n```','2019-09-05 11:07:18.000000','p','o','a',56,-1,1,2),(57,'2019-09-07 00:58:12.831219','2019-09-07 00:58:12.831224','个人简历','## 个人信息\r\n - 孙大众/男\r\n - 江西师范大学 网络工程专业\r\n - 工作年限：2年\r\n - 期望职位：python开发工程师\r\n - 期望城市：深圳\r\n\r\n## 联系方式\r\n - 手机: 18679602523\r\n - Email: 252301699@qq.com\r\n - 博客地址: http://sundazhong.com\r\n \r\n## 工作经历\r\n### 深圳点赞互娱科技有限公司 （ 2018年02月 ~ 至今 ）\r\n\r\n#### 线下房卡棋牌项目\r\n\r\n**项目描述**：开发独居地方特色的易管理、易运营的棋牌游戏，支持ios、android、web平台，支持大量用户在线，保证游戏平台的长时间稳定性。并且做好防篡改、防止攻击等工作。做好系统扩展、微服务部署的扩展需求。\r\n\r\n**项目概述与实现：**\r\n1. 通过gevent对协程的完善支持加上支持gevent的WSGI服务器来提高并发能力和系统稳定性。\r\n2. 通过WebSocket协议实现多平台与服务端的双向即时通信。\r\n3. 使用微服务架构，主要服务有：master服务、大厅服务、各游戏服务。各服务通过socket通信，由master统一调度，并且每个服务都实现了单独的管理。\r\n4. 管理后台、公众号等其他系统通过基于事件的redis的发布订阅模式通信。\r\n5. 客户端实现：基于laya游戏引擎提供的整套解决方案，通过node压缩、混淆、打包资源，嵌入原生平台实现打包。静态资源通过nginx托管，cdn加速。\r\n6. 微信公众号、管理后台：使用restapi风格，前后端分离。\r\n\r\n**职责：**\r\n1. 定位、语音、授权登陆、支付、分享等，通过原生实现，为js提供接口调用。\r\n2. 跑得快、红中麻将、斗地主、牛牛、金鲨银鲨、奔驰宝马游戏的前后端独立开发、单元测试\r\n3. 游戏控制策略的开发。\r\n4. laya客户端性能优化和兼容、打包。\r\n5. 其他模块的开发：个人信息、支付接口管理、对接支付、大厅涉及服务、商城、亲友圈接口\r\n6. 使用vue全家桶独立开发微信公众号前后端。\r\n7. 整个系统版本的迭代开发与维护\r\n\r\n\r\n### 中兴长天信息技术有限公司 （ 2016年11月 ~ 2018年02月 ）\r\n\r\n#### 昆明市“河长制”协同平台\r\n**项目描述**：系统主要目的是为了实现河水污染管制、责任划分、监控举报等。主要用户面向昆明市市民。\r\n采用B\\S架构，客户端主要有“河长制”协同平台（Web）、行政版App（单位工作人员）及公众版App（公众用户）\r\n\r\n**具体实现**:服务端使用java作为开发语言，服务端涉及spring、springmvc、mybatis、oracle、redis、nginx等技术栈。\r\nApp使用HBuilder提供的跨平台解决方案，涉及vue、vue-router、vuex、webpack、muiUI框架，涉及5+ sdk没有实现接口的业务，通过编写安卓和苹果原生为Js提供接口。\r\n\r\n### 周期偏短的项目  \r\n\r\n\r\n- 江西水资源二期app（一个月） \r\n    - 前后端分离，具体接口的具体业务实现\r\n    - 熟悉百度地图api、openlayers、echarts对砂船的定位、视频监控、首页信息展示。\r\n- 上饶水厂app（两个月）\r\n    -  参与需求的评审和制定\r\n    -  报文解析：bcd编码、crc校验\r\n    -  js与原生平台的回调通信\r\n    -  使用前后端分离的具体业务的编码实现\r\n- BDSS云平台web（三个月）\r\n    - 系统主要是为了实现记录公司产品版本信息、文档版本、项目跟进细节。初此之外还有数据元管理。\r\n    - 负责版本管理系统的具体需求评审和制定、数据库设计评审\r\n    - 基于jsp实现前后端开发\r\n\r\n\r\n\r\n## 技能清单\r\n- 熟悉常用数据结构和算法\r\n- 有良好的编程和注释习惯，熟悉常见设计模式，能在项目中灵活运用设计模式\r\n- 熟悉Python语言，了解Python多线程、多进程、协程和异步的应用场景。\r\n- 熟悉html、css、javascript、jquery、es6、websocket、laya、vue全家桶等技术\r\n- 熟悉Flask、Django、drf开发框架及部署方式，并有docker实践经验\r\n- 熟悉linux操作系统，掌握常用的linux命令\r\n- 熟练掌握svn、git版本管理工具等其他开发工具\r\n- 熟悉mysql、redis，了解mongodb，具有编写和优化SQL的能力\r\n\r\n---\r\n## 致谢\r\n感谢您花时间阅读我的简历，期待能有机会和您共事。','2019-09-07 00:57:29.000000','d','o','a',12,0,1,7),(58,'2019-09-08 10:23:23.320734','2019-09-08 10:23:23.320744','leetcode 自己实现堆排序','## 堆排序\r\n\r\n堆是一个近似完全二叉树的结构。存储在数组中\r\n\r\n\r\n## 题目\r\n![](/media/editor/微信截图_20190908232330_20190908102302545148.png)\r\n\r\n\r\n\r\n用python实现了一个最大堆\r\n\r\n```python\r\n\r\nfrom typing import List\r\n\r\n\r\nclass Solution:\r\n    def lastStoneWeight(self, stones: List[int]) -> int:\r\n        if not stones:\r\n            return 0\r\n        heap = MaxHeap(stones)\r\n        while heap.size() > 1:\r\n            x, y = heap.pop(), heap.pop()\r\n\r\n            if not y:\r\n                return y\r\n            if x != y:\r\n                heap.insert(abs(y - x))\r\n\r\n            if heap.size() == 0:\r\n                return 0\r\n\r\n        return heap.top()\r\n\r\n\r\nclass MaxHeap:\r\n\r\n    def __init__(self, arr):\r\n        self.data = arr\r\n        for i in range(len(arr) // 2, -1, -1):\r\n            self.heapify(i)\r\n\r\n    def heapify(self, index):\r\n        left = 2 * index + 1\r\n        right = 2 * index + 2\r\n        max_index = index\r\n\r\n        if left < len(self.data) and self.data[left] > self.data[max_index]:\r\n            max_index = left\r\n\r\n        if right < len(self.data) and self.data[right] > self.data[max_index]:\r\n            max_index = right\r\n\r\n        if max_index != index:\r\n            self.data[index], self.data[max_index] = self.data[max_index], self.data[index]\r\n            self.heapify(max_index)\r\n\r\n    def size(self):\r\n        return len(self.data)\r\n\r\n    def shift_up(self, index):\r\n        \"\"\"\r\n        一直和父节点比较 如果大就一直上浮\r\n        :param index:\r\n        :return:\r\n        \"\"\"\r\n        while self.data[index] > self.data[index // 2]:\r\n            self.data[index], self.data[index // 2] = self.data[index // 2], self.data[index]\r\n            index = index // 2\r\n\r\n    def top(self):\r\n        \"\"\"\r\n        获取最大堆的值\r\n        :return:\r\n        \"\"\"\r\n        if self.data:\r\n            return self.data[0]\r\n        return None\r\n\r\n    def insert(self, value):\r\n        \"\"\"\r\n        最大堆插入\r\n        :param value:\r\n        :return:\r\n        \"\"\"\r\n        self.data.append(value)\r\n        self.shift_up(len(self.data) - 1)\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        弹出堆顶元素\r\n        :return:\r\n        \"\"\"\r\n        if not self.data:\r\n            return None\r\n        self.data[0], self.data[len(self.data) - 1] = self.data[len(self.data) - 1], self.data[0]\r\n        top = self.data.pop()\r\n        self.heapify(0)\r\n        return top\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    arr = [i for i in range(20)]\r\n    # heap = MaxHeap(arr)\r\n    # print(heap.data)\r\n    # print(heap.top())  # 19\r\n    # heap.pop()\r\n    # heap.pop()\r\n    # heap.pop()\r\n    # heap.insert(100)\r\n    # a = Solution().lastStoneWeight(arr)\r\n    a = Solution().lastStoneWeight([2])\r\n    print(a)\r\n    # print(heap.top())  # 17\r\n\r\n\r\n```','2019-09-08 10:19:25.000000','p','o','a',88,0,1,2),(59,'2019-09-24 12:09:54.239676','2019-09-24 12:09:54.239682','leetcode 1081','有点烦躁，写题目\r\n```python\r\n# 返回字符串 text 中按字典序排列最小的子序列，该子序列包含 text 中所有不同字符一次。\r\n#\r\n#  \r\n#\r\n# 示例 1：\r\n#\r\n# 输入：\"cdadabcc\"\r\n# 输出：\"adbc\"\r\n# 示例 2：\r\n#\r\n# 输入：\"abcd\"\r\n# 输出：\"abcd\"\r\n# 示例 3：\r\n#\r\n# 输入：\"ecbacba\"\r\n# 输出：\"eacb\"\r\n# 示例 4：\r\n#\r\n# 输入：\"leetcode\"\r\n# 输出：\"letcod\"\r\n\r\n# 题目重点：子序列 字典序\r\n\r\n\r\nclass Solution:\r\n    def smallestSubsequence(self, text: str) -> str:\r\n        stack = []\r\n        for i in range(len(text)):\r\n            if text[i] in stack:\r\n                continue\r\n            while stack and ord(text[i]) < ord(stack[-1]) and text.find(stack[-1], i) != -1:\r\n                stack.pop()\r\n            stack.append(text[i])\r\n        return \"\".join(stack)\r\n\r\n```','2019-09-24 12:08:37.000000','p','o','a',65,0,1,2),(60,'2019-09-24 12:46:46.860687','2019-09-24 12:46:46.860694','python leetcode zip','```python\r\n# 给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。\r\n# \r\n# 删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符，形式上，第 n 列为 [A[0][n], A[1][n], ..., A[A.length-1][n]]）。\r\n# \r\n# 比如，有 A = [\"abcdef\", \"uvwxyz\"]，\r\n# \r\n# \r\n# \r\n# 要删掉的列为 {0, 2, 3}，删除后 A 为[\"bef\", \"vyz\"]， A 的列分别为[\"b\",\"v\"], [\"e\",\"y\"], [\"f\",\"z\"]。\r\n# \r\n# \r\n# \r\n# 你需要选出一组要删掉的列 D，对 A 执行删除操作，使 A 中剩余的每一列都是 非降序 排列的，然后请你返回 D.length 的最小可能值。\r\n# \r\n\r\nclass Solution(object):\r\n    def minDeletionSize(self, A):\r\n        ans = 0\r\n        print(A)  # [\'cba\', \'daf\', \'ghi\']\r\n        print(*A)  # cba daf ghi\r\n        print(zip(*A))  # <zip object at 0x000002291C890988>\r\n        for col in zip(*A):\r\n            print(col)\r\n            # (\'c\', \'d\', \'g\')\r\n            # (\'b\', \'a\', \'h\')\r\n            # (\'a\', \'f\', \'i\')\r\n            if any(col[i] > col[i + 1] for i in range(len(col) - 1)):\r\n                ans += 1\r\n        return ans\r\n\r\n\r\na = Solution().minDeletionSize([\"cba\", \"daf\", \"ghi\"])\r\nprint(a)\r\n\r\n```','2019-09-24 12:46:06.000000','p','o','a',62,0,1,2),(61,'2019-10-13 22:59:42.370606','2019-10-13 22:59:42.370612','RPC','使用python3.6\r\n\r\n## 单线程网络模型\r\n\r\nservice\r\n```python\r\n#!/usr/bin/env python\r\n# -*- coding: utf-8 -*-\r\n\"\"\"\r\nCreated by sundazhong on 2019/10/14 10:47.\r\n\"\"\"\r\nimport json\r\nimport struct\r\nimport socket\r\n\r\n\r\ndef loop(sock, handlers):\r\n	while True:\r\n		conn, address = sock.accept()\r\n		print(conn, address)\r\n		hand_handlers(conn, address, handlers)\r\n\r\n\r\ndef hand_handlers(conn, address, handlers):\r\n	print(\"{} come\".format(address))\r\n	while True:\r\n		request_len = conn.recv(4)\r\n		if not request_len:\r\n			print(\"{} bye\".format(address))\r\n			conn.close()\r\n			break\r\n		lenth, = struct.unpack(\"I\", request_len)\r\n		content = json.loads(conn.recv(lenth))\r\n		print(content)\r\n		_in = content[\'_in\']\r\n		params = content[\'params\']\r\n\r\n		handler_methods = handlers[_in]\r\n		handler_methods(conn, params)\r\n\r\n\r\ndef send_result(conn, params):\r\n	\"\"\"\r\n	使用sendAll方法\r\n	:param conn:\r\n	:param params:\r\n	:return:\r\n	\"\"\"\r\n	content = json.dumps(dict(name=\"pong\", body=params))\r\n	content_len = len(content)\r\n\r\n	length = struct.pack(\"I\", content_len)\r\n	conn.sendall(length)\r\n	conn.sendall(content.encode())\r\n\r\n\r\ndef ping(conn, params):\r\n	send_result(conn, params)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n	sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n	sock.setsockopt(socket.SOL_IP, socket.SO_REUSEADDR, 1)\r\n	sock.bind((\"localhost\", 8000))\r\n	sock.listen(1)\r\n\r\n	handlers = {\r\n		\"ping\": ping\r\n	}\r\n\r\n	loop(sock, handlers)\r\n\r\n```\r\n\r\n客户端\r\n```python\r\n#!/usr/bin/env python\r\n# -*- coding: utf-8 -*-\r\n\"\"\"\r\nCreated by sundazhong on 2019/10/14 10:55.\r\n\"\"\"\r\nimport socket\r\nimport time\r\nimport struct\r\nimport json\r\n\r\ndef rpc(conn, _in, params):\r\n	\"\"\"\r\n	发送\r\n	:param conn:\r\n	:param _in:\r\n	:param params:\r\n	:return:\r\n	\"\"\"\r\n	request = json.dumps(dict(_in=_in, params=params))\r\n	pre_len = struct.pack(\"I\", len(request))\r\n	conn.sendall(pre_len)\r\n	conn.sendall(request.encode())\r\n\r\n	response = conn.recv(4)\r\n	# 返回的是一个元组\r\n	res_len, = struct.unpack(\"I\", response)\r\n	body = conn.recv(res_len)\r\n	response = json.loads(body)\r\n	print(response)\r\n	return response[\'name\'], response[\'body\']\r\n\r\n\r\nif __name__ == \"__main__\":\r\n	sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n	sock.connect((\"0.0.0.0\", 8000))  # 是个元组\r\n\r\n	for i in range(10):\r\n		out, result = rpc(sock, \"ping\", \"hello %d\" % i)\r\n		print(out, result)\r\n		time.sleep(1)\r\n\r\n	sock.close()\r\n\r\n```\r\n\r\n单线程同步模型的服务器是最简单的服务器模型，每次只能处理一个客户端连接，其它连接必须等到前面的连接关闭了才能得到服务器的处理。\r\n否则发送过来的请求会悬挂住，没有任何响应，直到前面的连接处理完了才能继续。\r\n\r\n## 改进 多线程网络模型\r\n```python\r\n#!/usr/bin/env python\r\n# -*- coding: utf-8 -*-\r\n\"\"\"\r\nCreated by sundazhong on 2019/10/14 10:47.\r\n\"\"\"\r\nimport json\r\nimport struct\r\nimport _thread\r\n\r\nimport socket\r\n\r\n\r\ndef loop(sock, handlers):\r\n	while True:\r\n		conn, address = sock.accept()\r\n		print(conn, address)\r\n		# 多线程接受客户端\r\n		_thread.start_new_thread(hand_handlers, (conn, address, handlers))\r\n\r\n\r\ndef hand_handlers(conn, address, handlers):\r\n	print(\"{} come\".format(address))\r\n	while True:\r\n		request_len = conn.recv(4)\r\n		if not request_len:\r\n			print(\"{} bye\".format(address))\r\n			conn.close()\r\n			break\r\n		lenth, = struct.unpack(\"I\", request_len)\r\n		content = json.loads(conn.recv(lenth))\r\n		print(content)\r\n		_in = content[\'_in\']\r\n		params = content[\'params\']\r\n\r\n		handler_methods = handlers[_in]\r\n		handler_methods(conn, params)\r\n\r\n\r\ndef send_result(conn, params):\r\n	\"\"\"\r\n	使用sendAll方法\r\n	:param conn:\r\n	:param params:\r\n	:return:\r\n	\"\"\"\r\n	content = json.dumps(dict(name=\"pong\", body=params))\r\n	content_len = len(content)\r\n\r\n	length = struct.pack(\"I\", content_len)\r\n	conn.sendall(length)\r\n	conn.sendall(content.encode())\r\n\r\n\r\ndef ping(conn, params):\r\n	send_result(conn, params)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n	sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n	sock.setsockopt(socket.SOL_IP, socket.SO_REUSEADDR, 1)\r\n	sock.bind((\"localhost\", 8000))\r\n	sock.listen(1)\r\n\r\n	handlers = {\r\n		\"ping\": ping\r\n	}\r\n\r\n	loop(sock, handlers)\r\n\r\n```\r\n\r\n### 多进程网络模型\r\n```python\r\n#!/usr/bin/env python\r\n# -*- coding: utf-8 -*-\r\n\"\"\"\r\nCreated by sundazhong on 2019/10/14 10:47.\r\n\"\"\"\r\nimport json\r\nimport struct\r\nimport os\r\n\r\nimport socket\r\n\r\ndef loop(sock, handlers):\r\n	while True:\r\n		conn, address = sock.accept()\r\n\r\n		print(conn, address)\r\n\r\n		pid = os.fork()\r\n		print(\"pid======%s\" % pid)\r\n		if pid < 0:  # 资源不足 创建失败 直接返回\r\n			return\r\n		elif pid > 0:  # 关闭父进程的客户端套接字引用\r\n			conn.close()\r\n			continue\r\n		else:\r\n			hand_connect(conn, address, handlers)\r\n			conn.close()  # 关闭子进程的连接 处理完后一定要退出循环，不然子进程也会继续去 accept 连接\r\n			break\r\n\r\n\r\ndef hand_connect(conn, address, handlers):\r\n	print(\"{} come\".format(address))\r\n	while True:\r\n		request_len = conn.recv(4)\r\n		if not request_len:\r\n			print(\"{} bye\".format(address))\r\n			conn.close()\r\n			break\r\n		lenth, = struct.unpack(\"I\", request_len)\r\n		content = json.loads(conn.recv(lenth))\r\n		print(content)\r\n		_in = content[\'_in\']\r\n		params = content[\'params\']\r\n\r\n		handler_methods = handlers[_in]\r\n		handler_methods(conn, params)\r\n\r\n\r\ndef send_result(conn, params):\r\n	\"\"\"\r\n	使用sendAll方法\r\n	:param conn:\r\n	:param params:\r\n	:return:\r\n	\"\"\"\r\n	content = json.dumps(dict(name=\"pong\", body=params))\r\n	content_len = len(content)\r\n\r\n	length = struct.pack(\"I\", content_len)\r\n	conn.sendall(length)\r\n	conn.sendall(content.encode())\r\n\r\n\r\ndef ping(conn, params):\r\n	send_result(conn, params)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n	sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n	sock.setsockopt(socket.SOL_IP, socket.SO_REUSEADDR, 1)\r\n	sock.bind((\"localhost\", 8000))\r\n	sock.listen(1)\r\n\r\n	handlers = {\r\n		\"ping\": ping\r\n	}\r\n\r\n	loop(sock, handlers)\r\n\r\n```\r\n\r\n进程池\r\n```python\r\n#!/usr/bin/env python\r\n# -*- coding: utf-8 -*-\r\n\"\"\"\r\nCreated by sundazhong on 2019/10/14 10:47.\r\n\"\"\"\r\nimport json\r\nimport struct\r\nimport os\r\n\r\n\r\nimport socket\r\n\r\n\r\ndef loop(sock, handlers):\r\n	while True:\r\n		conn, address = sock.accept()\r\n\r\n		print(conn, address)\r\n\r\n		hand_connect(conn, address, handlers)\r\n\r\n\r\ndef hand_connect(conn, address, handlers):\r\n	print(\"{} come\".format(address))\r\n	while True:\r\n		request_len = conn.recv(4)\r\n		if not request_len:\r\n			print(\"{} bye\".format(address))\r\n			conn.close()\r\n			break\r\n		lenth, = struct.unpack(\"I\", request_len)\r\n		content = json.loads(conn.recv(lenth))\r\n		print(content)\r\n		_in = content[\'_in\']\r\n		params = content[\'params\']\r\n\r\n		handler_methods = handlers[_in]\r\n		handler_methods(conn, params)\r\n\r\n\r\ndef send_result(conn, params):\r\n	\"\"\"\r\n	使用sendAll方法\r\n	:param conn:\r\n	:param params:\r\n	:return:\r\n	\"\"\"\r\n	content = json.dumps(dict(name=\"pong\", body=params))\r\n	content_len = len(content)\r\n\r\n	length = struct.pack(\"I\", content_len)\r\n	conn.sendall(length)\r\n	conn.sendall(content.encode())\r\n\r\n\r\ndef ping(conn, params):\r\n	send_result(conn, params)\r\n\r\n\r\ndef prefork(n):\r\n	for i in range(n):\r\n		pid = os.fork()\r\n		if pid < 0:\r\n			return\r\n		if pid > 0:\r\n			continue\r\n		else:\r\n			break\r\n\r\n\r\nif __name__ == \"__main__\":\r\n	sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n	sock.setsockopt(socket.SOL_IP, socket.SO_REUSEADDR, 1)\r\n	sock.bind((\"localhost\", 8000))\r\n	sock.listen(1)\r\n\r\n	prefork(10)\r\n\r\n	handlers = {\r\n		\"ping\": ping\r\n	}\r\n\r\n	loop(sock, handlers)\r\n\r\n```\r\nprefork 之后，父进程创建的服务套接字引用，每个子进程也会继承一份，它们共同指向了操作系统内核的套接字对象，共享了同一份连接监听队列。子进程和父进程一样都可以对服务套接字进行 accept 调用，从共享的监听队列中摘取一个新连接进行处理\r\n\r\n\r\n## 单进程异步\r\n\r\n- 非阻塞io\r\n- 事件轮询\r\n- 进程读写缓冲区\r\n- python内置的异步io库 asyncore\r\n\r\n服务套接字的可读事件是指有新连接来了，它没有相应的可写事件。服务器套接字的读操作就是调用 accept 获取新连接。\r\n\r\n```python\r\n#!/usr/bin/env python\r\n# -*- coding: utf-8 -*-\r\n\"\"\"\r\nCreated by sundazhong on 2019/10/14 10:47.\r\n\"\"\"\r\nimport json\r\nimport struct\r\nimport socket\r\nimport asyncore\r\nfrom io import StringIO\r\n\r\n\r\nclass RPCHandler(asyncore.dispatcher_with_send):\r\n\r\n	def __init__(self, sock, addr):\r\n		super().__init__(sock)\r\n		self.addr = addr\r\n		self.handlers = {\r\n			\"ping\": self.ping\r\n		}\r\n		self.rbuf = StringIO()\r\n\r\n	def handle_connect(self):\r\n		\"\"\"\r\n		新的连接被accept后的方法\r\n		:return:\r\n		\"\"\"\r\n		print(\"come %s\" % self.addr)\r\n\r\n	def handle_close(self):\r\n		\"\"\"\r\n		关闭的时候\r\n		:return:\r\n		\"\"\"\r\n		print(\"%s bye\" % self.addr[0])\r\n		self.close()\r\n\r\n	def handle_read(self):\r\n		while True:\r\n			content = self.recv(1024)\r\n			if content:\r\n				print(\"收到发送的数据\")\r\n				print(content)\r\n				print(\"类型:%s\" % type(content))\r\n\r\n				self.rbuf.write(content.decode())\r\n			if len(content) < 1024:\r\n				break\r\n		self.handle_rpc()\r\n\r\n	def handle_rpc(self):\r\n		while True:\r\n			self.rbuf.seek(0)\r\n			request_len = self.rbuf.read(4)\r\n			# 不足一个消息\r\n			if len(request_len) < 4:\r\n				break\r\n\r\n			length, = struct.unpack(\"I\", request_len.encode())\r\n			body = self.rbuf.read(length)\r\n\r\n			print(\"传输的内容是:\")\r\n			print(body)\r\n			# 正文不足\r\n			if len(body) < length:\r\n				break\r\n			request = json.loads(body)\r\n			name = request[\'_in\']\r\n			params = request[\'params\']\r\n			handler = self.handlers[name]\r\n			# 事件处理\r\n			handler(params)\r\n			# 截取没有处理过的消息\r\n			left = self.rbuf.getvalue()[length + 4:]\r\n			self.rbuf = StringIO()\r\n			self.rbuf.write(left)\r\n\r\n		# 将游标移动到结尾\r\n		self.rbuf.seek(0, 2)\r\n\r\n	def send_result(self, out, body):\r\n		\"\"\"\r\n		发送结果\r\n		:param out:\r\n		:param body:\r\n		:return:\r\n		\"\"\"\r\n		response = json.dumps(dict(name=out, body=body))\r\n		length = len(response)\r\n\r\n		pre_len = struct.pack(\"I\", length)\r\n		print(\"=======send======\")\r\n		print(response)\r\n		self.send(pre_len)  # 写入缓冲区\r\n		self.send(response.encode())  # 写入缓冲区\r\n\r\n	def ping(self, params):\r\n		self.send_result(\"pong\", params)\r\n\r\n\r\nclass RPCServer(asyncore.dispatcher):\r\n\r\n	def __init__(self, host, port):\r\n		super().__init__()\r\n		self.create_socket(socket.AF_INET, socket.SOCK_STREAM)\r\n		self.set_reuse_addr()\r\n		self.bind((host, port))\r\n		self.listen(1)\r\n\r\n	def handle_accept(self):\r\n		pair = self.accept()\r\n		if pair is not None:\r\n			sock, addr = pair\r\n			RPCHandler(sock, addr)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n	RPCServer(\"localhost\", 8000)\r\n	# 开启时间轮询\r\n	asyncore.loop()\r\n\r\n```\r\n\r\n## PreForking异步\r\n开源框架 Tornado 和开源代理服务器 Nginx 正是采用了多进程 PreForking 异步模型达到了业界啧啧称奇的高并发的处理能力\r\n```python\r\n#!/usr/bin/env python\r\n# -*- coding: utf-8 -*-\r\n\"\"\"\r\nCreated by sundazhong on 2019/10/14 10:47.\r\n\"\"\"\r\nimport os\r\nimport json\r\nimport struct\r\nimport socket\r\nimport asyncore\r\nfrom io import StringIO\r\n\r\n\r\nclass RPCHandler(asyncore.dispatcher_with_send):\r\n\r\n	def __init__(self, sock, addr):\r\n		super().__init__(sock)\r\n		self.addr = addr\r\n		self.handlers = {\r\n			\"ping\": self.ping\r\n		}\r\n		self.rbuf = StringIO()\r\n\r\n	def handle_connect(self):\r\n		\"\"\"\r\n		新的连接被accept后的方法\r\n		:return:\r\n		\"\"\"\r\n		print(\"come %s\" % self.addr)\r\n\r\n	def handle_close(self):\r\n		\"\"\"\r\n		关闭的时候\r\n		:return:\r\n		\"\"\"\r\n		print(\"%s bye\" % self.addr[0])\r\n		self.close()\r\n\r\n	def handle_read(self):\r\n		while True:\r\n			content = self.recv(1024)\r\n			if content:\r\n				self.rbuf.write(content.decode())\r\n			if len(content) < 1024:\r\n				break\r\n		self.handle_rpc()\r\n\r\n	def handle_rpc(self):\r\n		while True:\r\n			self.rbuf.seek(0)\r\n			request_len = self.rbuf.read(4)\r\n			# 不足一个消息\r\n			if len(request_len) < 4:\r\n				break\r\n\r\n			length, = struct.unpack(\"I\", request_len.encode())\r\n			body = self.rbuf.read(length)\r\n\r\n			# 正文不足\r\n			if len(body) < length:\r\n				break\r\n			request = json.loads(body)\r\n			name = request[\'_in\']\r\n			params = request[\'params\']\r\n			print(\"pid:%s，name:%s， params:%s\" % (os.getpid(), name, params))\r\n			handler = self.handlers[name]\r\n			# 事件处理\r\n			handler(params)\r\n			# 截取没有处理过的消息\r\n			left = self.rbuf.getvalue()[length + 4:]\r\n			self.rbuf = StringIO()\r\n			self.rbuf.write(left)\r\n\r\n		# 将游标移动到结尾\r\n		self.rbuf.seek(0, 2)\r\n\r\n	def send_result(self, out, body):\r\n		\"\"\"\r\n		发送结果\r\n		:param out:\r\n		:param body:\r\n		:return:\r\n		\"\"\"\r\n		response = json.dumps(dict(name=out, body=body))\r\n		length = len(response)\r\n\r\n		pre_len = struct.pack(\"I\", length)\r\n		self.send(pre_len)  # 写入缓冲区\r\n		self.send(response.encode())  # 写入缓冲区\r\n\r\n	def ping(self, params):\r\n		self.send_result(\"pong\", params)\r\n\r\n\r\nclass RPCServer(asyncore.dispatcher):\r\n\r\n	def __init__(self, host, port):\r\n		super().__init__()\r\n		self.create_socket(socket.AF_INET, socket.SOCK_STREAM)\r\n		self.set_reuse_addr()\r\n		self.bind((host, port))\r\n		self.listen(1)\r\n\r\n		# 使用多进程\r\n		self.prefork(10)  # 开辟 10 个子进程\r\n\r\n	def handle_accept(self):\r\n		pair = self.accept()\r\n		if pair is not None:\r\n			sock, addr = pair\r\n			RPCHandler(sock, addr)\r\n\r\n	def prefork(self, n):\r\n		for i in range(n):\r\n			pid = os.fork()\r\n			if pid > 0:\r\n				continue\r\n			elif pid < 0:\r\n				return\r\n			else:\r\n				break\r\n\r\n\r\nif __name__ == \"__main__\":\r\n	RPCServer(\"localhost\", 8000)\r\n	asyncore.loop()\r\n\r\n```\r\n\r\n### 多进程描述符传递\r\n\r\nnginx并发模型是多进程并发模型\r\n它的 Master 进程在绑定监听地址端口后 fork 出了多个 Slave 进程共同竞争处理这个服务端套接字接收到的很多客户端连接\r\n多个 Slave 进程会共享同一个处于操作系统内核态的套接字队列。操作系统的网络模块在处理完三次握手后就会将套接字塞进这个队列。这是一个生产者消费者模型\r\n\r\n这种模型在负载均衡上有一个缺点，那就是套接字分配不均匀，形成了类似于贫富分化的局面，也就是「闲者愈闲，忙者愈忙」的状态。这是因为当多个进程竞争同一个套接字队列时，操作系统采用了 LIFO 的策略，最后一个来 accept 的进程最优先拿到 套接字。越是繁忙的进程越是有更多的机会调用 accept，它能拿到的套接字也就越多\r\n\r\nNode Cluster 并发模型\r\n\r\n为了解决负载均衡问题，它采用了不同的策略。它也是多进程并发模型，Master 进程会 fork 出多个子进程来处理客户端套接字。但是不存在竞争问题，因为负责 accept 套接字的只能是 Master 进程，Slave 进程只负责处理客户端套接字请求。\r\n\r\nsendmsg 登场了。它是操作系统提供的系统调用，可以在不同的进程之间传递文件描述符。sendmsg 会搭乘一个特殊的「管道」将 Master 进程的套接字描述符传递到 Slave 进程，Slave 进程通过 recvmsg 系统调用从这个「管道」中将描述符取出来。这个「管道」比较特殊，它是 Unix 域套接字。普通的套接字可以跨机器传输消息，Unix 域套接字只能在同一个机器的不同进程之间传递消息。同管道一样，Unix 域套接字也分为有名套接字和无名套接字，有名套接字会在文件系统指定一个路径名，无关进程之间都可以通过这个路径来访问 Unix 域套接字。而无名套接字一般用于父子进程之间，父进程会通过 socketpair 调用来创建套接字，然后 fork 出来子进程，这样子进程也会同时持有这个套接字的引用。后续父子进程就可以通过这个套接字互相通信。父子进程的描述符都会指向同一个内核套接字对象\r\n\r\n有了描述符的传递能力，父进程就可以将 accept 到的客户端套接字轮流传递给多个 Slave 进程，负载均衡的目标就可以顺利实现了\r\n```python\r\nimport os\r\nimport json\r\nimport struct\r\nimport socket\r\n\r\n\r\ndef handle_conn(conn, addr, handlers):\r\n	print(addr, \"comes\")\r\n	while True:\r\n		# 简单起见，这里就没有使用循环读取了\r\n		length_prefix = conn.recv(4)\r\n		if not length_prefix:\r\n			print(addr, \"bye\")\r\n			conn.close()\r\n			break  # 关闭连接，继续处理下一个连接\r\n		length, = struct.unpack(\"I\", length_prefix)\r\n		body = conn.recv(length)\r\n		request = json.loads(body)\r\n		in_ = request[\'_in\']\r\n		params = request[\'params\']\r\n		print(in_, params)\r\n		handler = handlers[in_]\r\n		handler(conn, params)\r\n\r\n\r\ndef loop_slave(pr, handlers):\r\n	while True:\r\n		bufsize = 1\r\n		ancsize = socket.CMSG_LEN(struct.calcsize(\'i\'))\r\n		msg, ancdata, flags, addr = pr.recvmsg(bufsize, ancsize)\r\n		cmsg_level, cmsg_type, cmsg_data = ancdata[0]\r\n		fd = struct.unpack(\'i\', cmsg_data)[0]\r\n		sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, fileno=fd)\r\n		handle_conn(sock, sock.getpeername(), handlers)\r\n\r\n\r\ndef ping(conn, params):\r\n	send_result(conn, \"pong\", params)\r\n\r\n\r\ndef send_result(conn, out, result):\r\n	response = json.dumps({\"name\": out, \"body\": result}).encode(\'utf-8\')\r\n	length_prefix = struct.pack(\"I\", len(response))\r\n	conn.sendall(length_prefix)\r\n	conn.sendall(response)\r\n\r\n\r\ndef loop_master(serv_sock, pws):\r\n	idx = 0\r\n	while True:\r\n		sock, addr = serv_sock.accept()\r\n		pw = pws[idx % len(pws)]\r\n		# 消息数据，whatever\r\n		msg = [b\'x\']\r\n		# 辅助数据，携带描述符\r\n		ancdata = [(\r\n			socket.SOL_SOCKET,\r\n			socket.SCM_RIGHTS,\r\n			struct.pack(\'i\', sock.fileno()))]\r\n		pw.sendmsg(msg, ancdata)\r\n		sock.close()  # 关闭引用\r\n		idx += 1\r\n\r\n\r\ndef prefork(serv_sock, n):\r\n	pws = []\r\n	for i in range(n):\r\n		# 开辟父子进程通信「管道」\r\n		pr, pw = socket.socketpair()\r\n		pid = os.fork()\r\n		if pid < 0:  # fork error\r\n			return pws\r\n		if pid > 0:\r\n			# 父进程\r\n			pr.close()  # 父进程不用读\r\n			pws.append(pw)\r\n			continue\r\n		if pid == 0:\r\n			# 子进程\r\n			serv_sock.close()  # 关闭引用\r\n			pw.close()  # 子进程不用写\r\n			return pr\r\n	return pws\r\n\r\n\r\nif __name__ == \'__main__\':\r\n	serv_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n	serv_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\r\n	serv_sock.bind((\"localhost\", 8000))\r\n	serv_sock.listen(1)\r\n	pws_or_pr = prefork(serv_sock, 10)\r\n	if hasattr(pws_or_pr, \'__len__\'):\r\n		if pws_or_pr:\r\n			loop_master(serv_sock, pws_or_pr)\r\n		else:\r\n			# fork 全部失败，没有子进程，Game Over\r\n			serv_sock.close()\r\n	else:\r\n		handlers = {\r\n			\"ping\": ping\r\n		}\r\n		loop_slave(pws_or_pr, handlers)\r\n\r\n```','2019-10-13 22:58:11.000000','p','o','a',49,0,1,2),(62,'2019-10-17 03:24:03.390110','2019-10-17 03:24:03.390116','python pyenv虚拟环境','1. 安装依赖\r\n```bash\r\nsudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvmgit \r\n\r\n```\r\n\r\n2. 安装pyenv\r\n\r\n```bash\r\ngit clone git://github.com/yyuu/pyenv.git ~/.pyenv\r\n```\r\n\r\n3. 配置环境变量\r\n\r\n```bash\r\necho -e \'\\n#pyenv\' >>~/.bashrc\r\necho \'export PATH=\"$HOME/.pyenv/bin:$PATH\"\' >> ~/.bashrc\r\necho \'eval \"$(pyenv init -)\"\' >> ~/.bashrc\r\necho \'eval \"$(pyenv virtualenv-init -)\"\' >> ~/.bashrc\r\n \r\nsource ~/.bashrc\r\n```\r\n\r\n4. 使用\r\n\r\n```bash\r\n\r\n# 1. 全部版本\r\npyenv versions\r\n\r\n# 2. 安装\r\npyenv install \r\n\r\n# 3. 创建\r\npyenv virtualenv 2.7.1 env271\r\n\r\n# 4. 激活\r\npyenv activate env271\r\n\r\n# 5. 退出\r\npyenv deactivate\r\n\r\n# 6. 删除\r\npyenv virtualenv-delete env271\r\n\r\n```','2019-10-17 03:23:13.000000','p','o','a',35,0,1,2),(63,'2019-10-21 20:35:41.848524','2019-10-21 20:35:41.848529','k8s 还没看完','k8s：\r\n1. 容器的应用部署、维护、滚动升级\r\n2. 负载均衡、服务发现\r\n3. 跨机器和跨地区的集群调度\r\n4. 自动伸缩\r\n5. 无状态服务和有状态服务\r\n6. 广泛的volume支持\r\n7. 插件机制保证扩展性\r\n\r\n\r\nPOD:\r\nKubernetes中最基本的调度单位是Pod，Pod从属于Node（物理机或虚拟机），Pod中可以运行多个Docker容器，会共享 PID、IPC、Network 和 UTS namespace。Pod在创建时会被分配一个IP地址，Pod间的容器可以互相通信\r\n\r\n\r\nYaml：\r\n如Pod、Deployment、Service等，都可以通过一个yaml文件来进行描述，并可以对这些对象进行CRUD操作（对应REST中的各种HTTP方法）\r\n\r\n\r\nNode:\r\n是Pod真正运行的主机，可以是物理机，也可以是虚拟机。为了管理 Pod，每个 Node 节点上至少要运行 container runtime、kubelet 和 kube-proxy 服务','2019-10-21 20:34:41.000000','p','o','a',35,0,1,7);
/*!40000 ALTER TABLE `blog_article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_article_tags`
--

DROP TABLE IF EXISTS `blog_article_tags`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_article_tags` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `article_id` int(11) NOT NULL,
  `tag_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `blog_article_tags_article_id_tag_id_b78a22e9_uniq` (`article_id`,`tag_id`),
  KEY `blog_article_tags_tag_id_88eb3ed9_fk_blog_tag_id` (`tag_id`),
  CONSTRAINT `blog_article_tags_article_id_82c02dd6_fk_blog_article_id` FOREIGN KEY (`article_id`) REFERENCES `blog_article` (`id`),
  CONSTRAINT `blog_article_tags_tag_id_88eb3ed9_fk_blog_tag_id` FOREIGN KEY (`tag_id`) REFERENCES `blog_tag` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=73 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_article_tags`
--

LOCK TABLES `blog_article_tags` WRITE;
/*!40000 ALTER TABLE `blog_article_tags` DISABLE KEYS */;
INSERT INTO `blog_article_tags` VALUES (1,1,1),(2,2,2),(3,2,3),(4,2,4),(5,2,5),(6,2,6),(7,3,7),(8,4,7),(9,5,7),(10,6,7),(11,7,7),(12,8,7),(13,9,7),(14,10,7),(15,11,7),(16,12,7),(17,13,7),(18,14,7),(19,15,7),(20,16,7),(21,17,7),(22,18,7),(23,19,7),(24,20,7),(25,21,7),(26,22,7),(27,23,7),(28,24,7),(29,25,7),(30,26,7),(31,27,7),(32,28,8),(33,29,9),(34,30,10),(35,31,9),(36,32,11),(37,32,12),(38,33,12),(39,33,13),(40,35,14),(41,36,15),(42,37,16),(48,37,21),(49,37,22),(47,37,24),(43,38,17),(44,39,18),(45,40,19),(46,41,20),(50,42,25),(51,43,26),(52,43,27),(53,44,5),(54,45,5),(55,46,28),(56,47,5),(57,48,27),(58,49,5),(59,51,27),(60,52,27),(62,53,5),(61,53,27),(63,54,27),(64,55,27),(65,56,27),(66,57,29),(67,59,27),(68,60,27),(69,61,5),(70,62,30),(71,63,3),(72,63,6);
/*!40000 ALTER TABLE `blog_article_tags` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_blogsettings`
--

DROP TABLE IF EXISTS `blog_blogsettings`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_blogsettings` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `sitename` varchar(200) NOT NULL,
  `site_description` longtext NOT NULL,
  `site_seo_description` longtext NOT NULL,
  `site_keywords` longtext NOT NULL,
  `article_sub_length` int(11) NOT NULL,
  `sidebar_article_count` int(11) NOT NULL,
  `sidebar_comment_count` int(11) NOT NULL,
  `show_google_adsense` tinyint(1) NOT NULL,
  `google_adsense_codes` longtext,
  `open_site_comment` tinyint(1) NOT NULL,
  `beiancode` varchar(2000) DEFAULT NULL,
  `analyticscode` longtext NOT NULL,
  `show_gongan_code` tinyint(1) NOT NULL,
  `gongan_beiancode` longtext,
  `resource_path` varchar(300) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_blogsettings`
--

LOCK TABLES `blog_blogsettings` WRITE;
/*!40000 ALTER TABLE `blog_blogsettings` DISABLE KEYS */;
INSERT INTO `blog_blogsettings` VALUES (1,'cococode','韬略终须无bug，发奋还得多编码 -- 改自郭沫若','Django,Python,docker,code,git,javascript,','Django,Python,docker,code,git,javascript,',300,10,5,0,'',1,'赣ICP备18012203号','<br/>',0,'赣ICP备18012203号','/var/www/resource/');
/*!40000 ALTER TABLE `blog_blogsettings` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_category`
--

DROP TABLE IF EXISTS `blog_category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_category` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `created_time` datetime(6) NOT NULL,
  `last_mod_time` datetime(6) NOT NULL,
  `name` varchar(30) NOT NULL,
  `slug` varchar(60) NOT NULL,
  `parent_category_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`),
  KEY `blog_category_parent_category_id_f50c3c0c_fk_blog_category_id` (`parent_category_id`),
  KEY `blog_category_slug_92643dc5` (`slug`),
  CONSTRAINT `blog_category_parent_category_id_f50c3c0c_fk_blog_category_id` FOREIGN KEY (`parent_category_id`) REFERENCES `blog_category` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_category`
--

LOCK TABLES `blog_category` WRITE;
/*!40000 ALTER TABLE `blog_category` DISABLE KEYS */;
INSERT INTO `blog_category` VALUES (1,'2019-08-13 04:13:13.244810','2019-08-13 04:13:13.244817','网站公告','wang-zhan-gong-gao',NULL),(2,'2019-08-13 06:20:58.157572','2019-08-13 06:20:58.157579','python','python',NULL),(3,'2019-08-13 06:21:06.749492','2019-08-13 06:21:06.749497','django','django',2),(5,'2019-08-13 07:00:38.415575','2019-08-13 07:00:38.415581','设计模式','she-ji-mo-shi',NULL),(6,'2019-08-13 11:25:59.507914','2019-08-13 11:25:59.507919','数据库','shu-ju-ku',NULL),(7,'2019-08-13 11:31:27.200903','2019-08-13 11:31:27.200909','工具','gong-ju',NULL),(8,'2019-08-15 11:17:35.461993','2019-08-15 11:17:35.462000','javascript','javascript',NULL);
/*!40000 ALTER TABLE `blog_category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_links`
--

DROP TABLE IF EXISTS `blog_links`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_links` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(30) NOT NULL,
  `link` varchar(200) NOT NULL,
  `sequence` int(11) NOT NULL,
  `is_enable` tinyint(1) NOT NULL,
  `show_type` varchar(1) NOT NULL,
  `created_time` datetime(6) NOT NULL,
  `last_mod_time` datetime(6) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`),
  UNIQUE KEY `sequence` (`sequence`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_links`
--

LOCK TABLES `blog_links` WRITE;
/*!40000 ALTER TABLE `blog_links` DISABLE KEYS */;
/*!40000 ALTER TABLE `blog_links` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_sidebar`
--

DROP TABLE IF EXISTS `blog_sidebar`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_sidebar` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) NOT NULL,
  `content` longtext NOT NULL,
  `sequence` int(11) NOT NULL,
  `is_enable` tinyint(1) NOT NULL,
  `created_time` datetime(6) NOT NULL,
  `last_mod_time` datetime(6) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `sequence` (`sequence`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_sidebar`
--

LOCK TABLES `blog_sidebar` WRITE;
/*!40000 ALTER TABLE `blog_sidebar` DISABLE KEYS */;
/*!40000 ALTER TABLE `blog_sidebar` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_tag`
--

DROP TABLE IF EXISTS `blog_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `created_time` datetime(6) NOT NULL,
  `last_mod_time` datetime(6) NOT NULL,
  `name` varchar(30) NOT NULL,
  `slug` varchar(60) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`),
  KEY `blog_tag_slug_01068d0e` (`slug`)
) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_tag`
--

LOCK TABLES `blog_tag` WRITE;
/*!40000 ALTER TABLE `blog_tag` DISABLE KEYS */;
INSERT INTO `blog_tag` VALUES (1,'2019-08-13 04:14:06.644702','2019-08-13 04:14:06.644707','好的开头吧','hao-de-kai-tou-ba'),(2,'2019-08-13 06:21:54.640414','2019-08-13 06:21:54.640420','django','django'),(3,'2019-08-13 06:22:00.817508','2019-08-13 06:22:00.817513','docker','docker'),(4,'2019-08-13 06:22:04.634925','2019-08-13 06:22:04.634930','nginx','nginx'),(5,'2019-08-13 06:22:09.430088','2019-08-13 06:22:09.430094','python','python'),(6,'2019-08-13 06:22:26.610116','2019-08-13 06:22:26.610123','docker-composer','docker-composer'),(7,'2019-08-13 07:00:47.303001','2019-08-13 07:00:47.303007','设计模式','she-ji-mo-shi'),(8,'2019-08-13 11:26:18.445528','2019-08-13 11:26:18.445534','mongodb','mongodb'),(9,'2019-08-13 11:27:27.790155','2019-08-13 11:27:27.790162','mysql','mysql'),(10,'2019-08-13 11:28:03.207231','2019-08-13 11:28:03.207237','redis','redis'),(11,'2019-08-13 11:31:34.201352','2019-08-13 11:31:34.201357','git','git'),(12,'2019-08-13 11:31:40.408984','2019-08-13 11:31:40.408989','工具','gong-ju'),(13,'2019-08-13 11:32:23.617304','2019-08-13 11:32:23.617309','gitbook','gitbook'),(14,'2019-08-15 03:25:13.573952','2019-08-15 03:25:13.573958','正则表达式','zheng-ze-biao-da-shi'),(15,'2019-08-15 11:17:44.125142','2019-08-15 11:17:44.125147','js复制','jsfu-zhi'),(16,'2019-08-17 03:58:57.236977','2019-08-17 03:58:57.236983','python常用','pythonchang-yong'),(17,'2019-08-17 04:36:56.200629','2019-08-17 04:36:56.200633','装饰器','zhuang-shi-qi'),(18,'2019-08-19 22:44:57.721337','2019-08-19 22:44:57.721342','python标准库','pythonbiao-zhun-ku'),(19,'2019-08-21 07:24:00.546745','2019-08-21 07:24:00.546751','python多线程和多进程','pythonduo-xian-cheng-he-duo-jin-cheng'),(20,'2019-08-22 04:01:36.170659','2019-08-22 04:01:36.170665','协程','xie-cheng'),(21,'2019-08-22 04:02:57.709197','2019-08-22 04:02:57.709202','map','map'),(22,'2019-08-22 04:03:02.813490','2019-08-22 04:03:02.813494','filter','filter'),(24,'2019-08-22 04:03:28.338685','2019-08-22 04:03:28.338690','yield','yield'),(25,'2019-08-23 06:32:27.829775','2019-08-23 06:32:27.829781','基础','ji-chu'),(26,'2019-08-24 04:20:46.883911','2019-08-24 04:20:46.883917','链表','lian-biao'),(27,'2019-08-24 04:20:51.942545','2019-08-24 04:20:51.942551','leetcode','leetcode'),(28,'2019-09-01 13:17:12.483558','2019-09-01 13:17:12.483564','工作总结','gong-zuo-zong-jie'),(29,'2019-09-07 00:58:11.164522','2019-09-07 00:58:11.164526','个人简历','ge-ren-jian-li'),(30,'2019-10-17 03:23:59.980508','2019-10-17 03:23:59.980513','虚拟环境','xu-ni-huan-jing');
/*!40000 ALTER TABLE `blog_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `comments_comment`
--

DROP TABLE IF EXISTS `comments_comment`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `comments_comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `body` longtext NOT NULL,
  `created_time` datetime(6) NOT NULL,
  `last_mod_time` datetime(6) NOT NULL,
  `is_enable` tinyint(1) NOT NULL,
  `article_id` int(11) NOT NULL,
  `author_id` int(11) NOT NULL,
  `parent_comment_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `comments_comment_article_id_94fe60a2_fk_blog_article_id` (`article_id`),
  KEY `comments_comment_author_id_334ce9e2_fk_accounts_bloguser_id` (`author_id`),
  KEY `comments_comment_parent_comment_id_71289d4a_fk_comments_` (`parent_comment_id`),
  CONSTRAINT `comments_comment_article_id_94fe60a2_fk_blog_article_id` FOREIGN KEY (`article_id`) REFERENCES `blog_article` (`id`),
  CONSTRAINT `comments_comment_author_id_334ce9e2_fk_accounts_bloguser_id` FOREIGN KEY (`author_id`) REFERENCES `accounts_bloguser` (`id`),
  CONSTRAINT `comments_comment_parent_comment_id_71289d4a_fk_comments_` FOREIGN KEY (`parent_comment_id`) REFERENCES `comments_comment` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `comments_comment`
--

LOCK TABLES `comments_comment` WRITE;
/*!40000 ALTER TABLE `comments_comment` DISABLE KEYS */;
INSERT INTO `comments_comment` VALUES (1,'优秀','2019-08-13 06:26:01.911451','2019-08-13 06:26:01.911459',1,1,1,NULL),(2,'大佬大佬','2019-09-26 02:00:36.411416','2019-09-26 02:00:36.411423',1,50,1,NULL);
/*!40000 ALTER TABLE `comments_comment` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `django_admin_log`
--

DROP TABLE IF EXISTS `django_admin_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `django_admin_log` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `action_time` datetime(6) NOT NULL,
  `object_id` longtext,
  `object_repr` varchar(200) NOT NULL,
  `action_flag` smallint(5) unsigned NOT NULL,
  `change_message` longtext NOT NULL,
  `content_type_id` int(11) DEFAULT NULL,
  `user_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `django_admin_log_content_type_id_c4bce8eb_fk_django_co` (`content_type_id`),
  KEY `django_admin_log_user_id_c564eba6_fk_accounts_bloguser_id` (`user_id`),
  CONSTRAINT `django_admin_log_content_type_id_c4bce8eb_fk_django_co` FOREIGN KEY (`content_type_id`) REFERENCES `django_content_type` (`id`),
  CONSTRAINT `django_admin_log_user_id_c564eba6_fk_accounts_bloguser_id` FOREIGN KEY (`user_id`) REFERENCES `accounts_bloguser` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=202 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `django_admin_log`
--

LOCK TABLES `django_admin_log` WRITE;
/*!40000 ALTER TABLE `django_admin_log` DISABLE KEYS */;
INSERT INTO `django_admin_log` VALUES (1,'2019-08-13 03:42:42.048300','2','',1,'[{\"added\": {}}]',13,1),(2,'2019-08-13 03:45:26.876004','2','862752581@qq.com',2,'[{\"changed\": {\"fields\": [\"email\", \"is_active\", \"is_superuser\"]}}]',13,1),(3,'2019-08-13 04:13:13.385032','1','首页',1,'[{\"added\": {}}]',11,1),(4,'2019-08-13 04:14:06.780831','1','好的开头吧',1,'[{\"added\": {}}]',10,1),(5,'2019-08-13 04:14:31.096773','1','Hello world',1,'[{\"added\": {}}]',12,1),(6,'2019-08-13 06:20:58.593836','2','python',1,'[{\"added\": {}}]',11,1),(7,'2019-08-13 06:21:06.968215','3','django',1,'[{\"added\": {}}]',11,1),(8,'2019-08-13 06:21:27.157743','4','项目经验',1,'[{\"added\": {}}]',11,1),(9,'2019-08-13 06:21:54.860448','2','django',1,'[{\"added\": {}}]',10,1),(10,'2019-08-13 06:22:00.937104','3','docker',1,'[{\"added\": {}}]',10,1),(11,'2019-08-13 06:22:04.745509','4','nginx',1,'[{\"added\": {}}]',10,1),(12,'2019-08-13 06:22:09.603038','5','python',1,'[{\"added\": {}}]',10,1),(13,'2019-08-13 06:22:26.799363','6','docker-composer',1,'[{\"added\": {}}]',10,1),(14,'2019-08-13 06:23:17.745236','2','docker集成django项目开发环境的过程',1,'[{\"added\": {}}]',12,1),(15,'2019-08-13 06:31:23.986452','2','docker集成django项目开发环境的过程',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(16,'2019-08-13 07:00:38.538760','5','设计模式',1,'[{\"added\": {}}]',11,1),(17,'2019-08-13 07:00:47.461215','7','设计模式',1,'[{\"added\": {}}]',10,1),(18,'2019-08-13 07:00:50.480342','3','设计模式',1,'[{\"added\": {}}]',12,1),(19,'2019-08-13 07:01:36.058652','1','网站公告',2,'[{\"changed\": {\"fields\": [\"name\"]}}]',11,1),(20,'2019-08-13 07:02:01.698210','4','项目经验',3,'',11,1),(21,'2019-08-13 07:12:47.218434','1','web',2,'[{\"changed\": {\"fields\": [\"site_description\", \"site_seo_description\", \"site_keywords\", \"analyticscode\", \"show_gongan_code\", \"gongan_beiancode\"]}}]',7,1),(22,'2019-08-13 07:15:02.390018','1','python是世界上最好的语言',2,'[{\"changed\": {\"fields\": [\"sitename\", \"analyticscode\"]}}]',7,1),(23,'2019-08-13 07:48:51.917976','4','单例设计模式',1,'[{\"added\": {}}]',12,1),(24,'2019-08-13 07:50:48.083754','5','简单工厂模式',1,'[{\"added\": {}}]',12,1),(25,'2019-08-13 07:51:53.823705','6','代理模式',1,'[{\"added\": {}}]',12,1),(26,'2019-08-13 07:52:19.024971','7','原型模式',1,'[{\"added\": {}}]',12,1),(27,'2019-08-13 07:53:30.129186','8','发布订阅模式（观察者模式）',1,'[{\"added\": {}}]',12,1),(28,'2019-08-13 07:54:03.625015','9','备忘录模式',1,'[{\"added\": {}}]',12,1),(29,'2019-08-13 07:55:29.420755','10','外观模式',1,'[{\"added\": {}}]',12,1),(30,'2019-08-13 07:56:00.017858','11','工厂模式',1,'[{\"added\": {}}]',12,1),(31,'2019-08-13 07:56:26.141839','12','建造者模式',1,'[{\"added\": {}}]',12,1),(32,'2019-08-13 07:57:47.040534','13','模板方法模式',1,'[{\"added\": {}}]',12,1),(33,'2019-08-13 07:58:06.907463','14','状态模式',1,'[{\"added\": {}}]',12,1),(34,'2019-08-13 08:00:21.535892','15','策略模式',1,'[{\"added\": {}}]',12,1),(35,'2019-08-13 08:01:28.533570','16','组合模式',1,'[{\"added\": {}}]',12,1),(36,'2019-08-13 08:01:50.029043','17','装饰者模式',1,'[{\"added\": {}}]',12,1),(37,'2019-08-13 08:14:23.387921','17','装饰者模式',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(38,'2019-08-13 08:14:55.574888','18','适配器模式',1,'[{\"added\": {}}]',12,1),(39,'2019-08-13 08:24:30.753043','19','桥接模式',1,'[{\"added\": {}}]',12,1),(40,'2019-08-13 08:28:08.313823','16','组合模式',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(41,'2019-08-13 08:32:48.554337','17','装饰者模式',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(42,'2019-08-13 08:34:33.692007','10','外观模式',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(43,'2019-08-13 08:37:04.822340','20','享元模式',1,'[{\"added\": {}}]',12,1),(44,'2019-08-13 08:40:16.640646','6','代理模式',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(45,'2019-08-13 09:07:09.030934','21','抽象工厂',1,'[{\"added\": {}}]',12,1),(46,'2019-08-13 09:08:32.719349','21','抽象工厂',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(47,'2019-08-13 09:08:59.824777','11','工厂模式',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(48,'2019-08-13 09:09:17.625710','12','建造者模式',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(49,'2019-08-13 09:12:04.845447','7','原型模式',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(50,'2019-08-13 09:31:35.288828','13','模板方法模式',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(51,'2019-08-13 09:32:09.104024','22','中介者模式',1,'[{\"added\": {}}]',12,1),(52,'2019-08-13 09:32:58.573963','23','命令模式',1,'[{\"added\": {}}]',12,1),(53,'2019-08-13 09:34:38.701222','24','责任链模式',1,'[{\"added\": {}}]',12,1),(54,'2019-08-13 09:35:14.145841','15','策略模式',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(55,'2019-08-13 09:35:46.512294','25','迭代器模式',1,'[{\"added\": {}}]',12,1),(56,'2019-08-13 09:36:56.431768','8','发布订阅模式（观察者模式）',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(57,'2019-08-13 09:37:33.241177','14','状态模式',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(58,'2019-08-13 09:40:08.531876','9','备忘录模式',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(59,'2019-08-13 09:40:38.719708','26','解释器模式',1,'[{\"added\": {}}]',12,1),(60,'2019-08-13 09:42:17.010436','27','访问者模式',1,'[{\"added\": {}}]',12,1),(61,'2019-08-13 11:25:59.673708','6','数据库',1,'[{\"added\": {}}]',11,1),(62,'2019-08-13 11:26:18.608955','8','mongodb',1,'[{\"added\": {}}]',10,1),(63,'2019-08-13 11:26:25.149142','28','mongodb',1,'[{\"added\": {}}]',12,1),(64,'2019-08-13 11:27:27.917369','9','mysql',1,'[{\"added\": {}}]',10,1),(65,'2019-08-13 11:27:29.856710','29','mysql',1,'[{\"added\": {}}]',12,1),(66,'2019-08-13 11:28:03.334377','10','redis',1,'[{\"added\": {}}]',10,1),(67,'2019-08-13 11:28:04.665163','30','redis',1,'[{\"added\": {}}]',12,1),(68,'2019-08-13 11:30:02.378536','31','mysql批量备份数据',1,'[{\"added\": {}}]',12,1),(69,'2019-08-13 11:31:27.332643','7','工具',1,'[{\"added\": {}}]',11,1),(70,'2019-08-13 11:31:34.325512','11','git',1,'[{\"added\": {}}]',10,1),(71,'2019-08-13 11:31:40.547777','12','工具',1,'[{\"added\": {}}]',10,1),(72,'2019-08-13 11:31:42.046670','32','git常用命令',1,'[{\"added\": {}}]',12,1),(73,'2019-08-13 11:32:23.755222','13','gitbook',1,'[{\"added\": {}}]',10,1),(74,'2019-08-13 11:32:27.815866','33','gitbook',1,'[{\"added\": {}}]',12,1),(75,'2019-08-13 11:43:41.612150','1','python是世界上最好的语言',2,'[{\"changed\": {\"fields\": [\"site_description\", \"beiancode\", \"analyticscode\", \"show_gongan_code\"]}}]',7,1),(76,'2019-08-13 11:44:29.774018','1','python是世界上最好的语言',2,'[{\"changed\": {\"fields\": [\"analyticscode\"]}}]',7,1),(77,'2019-08-13 11:56:20.636137','1','sundazhong.com',2,'[{\"changed\": {\"fields\": [\"domain\", \"name\"]}}]',6,1),(78,'2019-08-13 12:12:34.718826','34','为什么要做这个博客网站',1,'[{\"added\": {}}]',12,1),(79,'2019-08-13 12:14:44.128159','34','为什么要做这个博客网站',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(80,'2019-08-13 12:20:36.461229','34','为什么要做这个博客网站',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(81,'2019-08-13 12:31:17.269426','1','Hello world',2,'[{\"changed\": {\"fields\": [\"body\", \"article_order\"]}}]',12,1),(82,'2019-08-13 12:37:09.117006','1','Hello world',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(83,'2019-08-14 07:36:43.581412','1','Hello world',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(84,'2019-08-15 03:25:13.891219','14','正则表达式',1,'[{\"added\": {}}]',10,1),(85,'2019-08-15 03:25:19.642065','35','正则表达式',1,'[{\"added\": {}}]',12,1),(86,'2019-08-15 06:06:41.395892','1','抽烟喝酒烫头',2,'[{\"changed\": {\"fields\": [\"sitename\"]}}]',7,1),(87,'2019-08-15 06:10:46.822693','1','python',2,'[{\"changed\": {\"fields\": [\"sitename\"]}}]',7,1),(88,'2019-08-15 10:46:04.873422','34','为什么要做这个博客网站',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(89,'2019-08-15 11:17:35.606711','8','javascript',1,'[{\"added\": {}}]',11,1),(90,'2019-08-15 11:17:44.265184','15','js复制',1,'[{\"added\": {}}]',10,1),(91,'2019-08-15 11:17:46.028150','36','JavaScript中对象复制',1,'[{\"added\": {}}]',12,1),(92,'2019-08-15 11:44:05.843622','36','JavaScript中对象复制',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(93,'2019-08-15 11:51:07.077891','34','为什么要做这个博客网站',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(94,'2019-08-15 12:00:27.275850','36','JavaScript中对象复制',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(95,'2019-08-17 03:58:57.606195','16','python常用',1,'[{\"added\": {}}]',10,1),(96,'2019-08-17 03:59:00.257115','37','python生成器',1,'[{\"added\": {}}]',12,1),(97,'2019-08-17 04:36:56.561052','17','装饰器',1,'[{\"added\": {}}]',10,1),(98,'2019-08-17 04:36:58.201600','38','python装饰器',1,'[{\"added\": {}}]',12,1),(99,'2019-08-17 04:37:30.607261','38','python装饰器',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(100,'2019-08-19 22:44:58.084116','18','python标准库',1,'[{\"added\": {}}]',10,1),(101,'2019-08-19 22:45:01.186483','39','python标准库模块',1,'[{\"added\": {}}]',12,1),(102,'2019-08-20 12:43:37.601124','1','coco可乐',2,'[{\"changed\": {\"fields\": [\"sitename\", \"site_description\"]}}]',7,1),(103,'2019-08-21 07:24:01.177799','19','python多线程和多进程',1,'[{\"added\": {}}]',10,1),(104,'2019-08-21 07:24:04.557233','40','python多线程和多进程',1,'[{\"added\": {}}]',12,1),(105,'2019-08-21 09:07:34.454193','40','python多线程和多进程',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(106,'2019-08-21 12:17:30.574543','40','python多线程和多进程',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(107,'2019-08-21 12:20:20.335013','40','python多线程和多进程',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(108,'2019-08-21 12:23:17.565592','40','python多线程和多进程',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(109,'2019-08-22 03:48:53.359937','40','python多线程和多进程',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(110,'2019-08-22 04:01:36.330175','20','协程',1,'[{\"added\": {}}]',10,1),(111,'2019-08-22 04:01:39.891511','41','用协程来并发的运行多个函数',1,'[{\"added\": {}}]',12,1),(112,'2019-08-22 04:02:57.845841','21','map',1,'[{\"added\": {}}]',10,1),(113,'2019-08-22 04:03:02.953503','22','filter',1,'[{\"added\": {}}]',10,1),(114,'2019-08-22 04:03:08.026190','23','yeild',1,'[{\"added\": {}}]',10,1),(115,'2019-08-22 04:03:28.477080','24','yield',1,'[{\"added\": {}}]',10,1),(116,'2019-08-22 04:03:41.274010','37','python生成器',2,'[{\"changed\": {\"fields\": [\"tags\"]}}]',12,1),(117,'2019-08-22 04:03:54.671818','23','yeild',3,'',10,1),(118,'2019-08-22 07:38:54.867015','37','python生成器',2,'[]',12,1),(119,'2019-08-22 07:55:02.241447','37','生成器、迭代器、列表推导式',2,'[{\"changed\": {\"fields\": [\"title\", \"body\"]}}]',12,1),(120,'2019-08-22 08:04:11.841267','41','用协程来并发的运行多个函数',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(121,'2019-08-22 09:03:26.736630','37','生成器、迭代器、列表推导式',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(122,'2019-08-22 09:45:09.291581','41','python协程',2,'[{\"changed\": {\"fields\": [\"title\", \"body\"]}}]',12,1),(123,'2019-08-22 10:43:07.965914','41','python协程',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(124,'2019-08-23 06:32:27.978596','25','基础',1,'[{\"added\": {}}]',10,1),(125,'2019-08-23 06:32:29.222917','42','python基础扫盲',1,'[{\"added\": {}}]',12,1),(126,'2019-08-23 07:01:18.600106','42','python基础扫盲',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(127,'2019-08-23 09:20:23.062466','42','python基础扫盲',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(128,'2019-08-23 10:28:04.590164','42','python基础扫盲',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(129,'2019-08-23 11:43:38.239488','42','python基础扫盲',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(130,'2019-08-24 04:20:47.042475','26','链表',1,'[{\"added\": {}}]',10,1),(131,'2019-08-24 04:20:52.120219','27','leetcode',1,'[{\"added\": {}}]',10,1),(132,'2019-08-24 04:20:54.412774','43','链表反转',1,'[{\"added\": {}}]',12,1),(133,'2019-08-24 11:38:01.024844','1','Hello world',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(134,'2019-08-24 12:02:39.777070','44','python内置的队列',1,'[{\"added\": {}}]',12,1),(135,'2019-08-25 23:49:40.252484','42','python基础扫盲',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(136,'2019-08-28 12:03:52.258629','29','mysql',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(137,'2019-09-01 09:52:36.360562','45','python面试',1,'[{\"added\": {}}]',12,1),(138,'2019-09-01 09:57:16.920429','45','python面试',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(139,'2019-09-01 09:57:34.554774','34','为什么要做这个博客网站',2,'[{\"changed\": {\"fields\": [\"article_order\"]}}]',12,1),(140,'2019-09-01 10:05:48.721398','1','coco可乐',2,'[{\"changed\": {\"fields\": [\"site_description\"]}}]',7,1),(141,'2019-09-01 10:28:58.972452','45','python面试',2,'[{\"changed\": {\"fields\": [\"body\", \"views\"]}}]',12,1),(142,'2019-09-01 10:28:59.145960','45','python面试',2,'[]',12,1),(143,'2019-09-01 13:17:12.677597','28','工作总结',1,'[{\"added\": {}}]',10,1),(144,'2019-09-01 13:17:15.446610','46','九月二号',1,'[{\"added\": {}}]',12,1),(145,'2019-09-01 13:20:49.144537','46','九月二号',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(146,'2019-09-02 01:19:52.634349','46','九月二号',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(147,'2019-09-02 03:10:52.841003','47','flask',1,'[{\"added\": {}}]',12,1),(148,'2019-09-02 03:14:22.550753','47','flask',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(149,'2019-09-02 04:53:00.881488','47','flask',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(150,'2019-09-02 08:24:29.057486','47','flask',2,'[]',12,1),(151,'2019-09-04 00:17:20.085687','29','mysql',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(152,'2019-09-04 07:12:01.447390','29','mysql',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(153,'2019-09-04 07:33:00.540435','29','mysql',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(154,'2019-09-04 11:12:15.144360','48','leetcode 冒泡排序',1,'[{\"added\": {}}]',12,1),(155,'2019-09-04 11:15:27.939048','46','九月二号',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(156,'2019-09-04 11:16:44.765670','29','mysql',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(157,'2019-09-04 11:41:50.005962','49','罗湖面经过程',1,'[{\"added\": {}}]',12,1),(158,'2019-09-04 12:06:13.236707','49','罗湖面经过程',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(159,'2019-09-04 12:07:31.282917','49','罗湖面经过程',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(160,'2019-09-04 12:08:14.624132','49','罗湖面经过程',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(161,'2019-09-04 12:09:35.891083','49','罗湖面经过程',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(162,'2019-09-04 12:13:03.922536','1','Hello world',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(163,'2019-09-04 12:16:46.196818','50','TODOLIST',1,'[{\"added\": {}}]',12,1),(164,'2019-09-04 12:17:22.782640','50','TODOLIST',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(165,'2019-09-04 12:17:53.787289','50','TODOLIST',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(166,'2019-09-04 12:21:08.330277','1','coco可乐',2,'[{\"changed\": {\"fields\": [\"site_description\"]}}]',7,1),(167,'2019-09-05 02:31:15.990690','42','python基础扫盲',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(168,'2019-09-05 03:45:48.776258','51','leetcode 指定面积最趋近于一个正方形',1,'[{\"added\": {}}]',12,1),(169,'2019-09-05 05:26:11.133505','52','leetcode 返回质数的个数（厄拉多塞筛法）',1,'[{\"added\": {}}]',12,1),(170,'2019-09-05 08:41:13.919687','53','leetcode 递归带货，深度优先',1,'[{\"added\": {}}]',12,1),(171,'2019-09-05 09:23:55.567163','54','leetcode nim游戏',1,'[{\"added\": {}}]',12,1),(172,'2019-09-05 10:42:41.820646','55','leetcode 二叉搜索树',1,'[{\"added\": {}}]',12,1),(173,'2019-09-05 10:43:14.281663','55','leetcode 二叉搜索树',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(174,'2019-09-05 11:08:37.770825','56','leetcode 拼接链表',1,'[{\"added\": {}}]',12,1),(175,'2019-09-06 23:44:28.350519','4','单例设计模式',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(176,'2019-09-07 00:58:11.385547','29','个人简历',1,'[{\"added\": {}}]',10,1),(177,'2019-09-07 00:58:13.458599','57','个人简历',1,'[{\"added\": {}}]',12,1),(178,'2019-09-07 01:00:34.514537','57','个人简历',2,'[{\"changed\": {\"fields\": [\"status\"]}}]',12,1),(179,'2019-09-07 01:04:11.591500','1','cococode',2,'[{\"changed\": {\"fields\": [\"sitename\", \"site_description\"]}}]',7,1),(180,'2019-09-07 01:07:39.946102','1','cococode',2,'[{\"changed\": {\"fields\": [\"site_description\"]}}]',7,1),(181,'2019-09-08 08:06:23.874511','48','leetcode 冒泡排序',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(182,'2019-09-08 10:19:18.935789','48','leetcode 冒泡排序和常见排序',2,'[{\"changed\": {\"fields\": [\"title\", \"body\"]}}]',12,1),(183,'2019-09-08 10:23:23.609780','58','leetcode 自己实现堆排序',1,'[{\"added\": {}}]',12,1),(184,'2019-09-08 10:28:39.993077','29','mysql',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(185,'2019-09-08 10:29:49.042443','50','TODOLIST',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(186,'2019-09-08 10:30:54.202808','50','TODOLIST',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(187,'2019-09-24 12:09:55.819331','59','leetcode 1081',1,'[{\"added\": {}}]',12,1),(188,'2019-09-24 12:46:47.140970','60','python leetcode zip',1,'[{\"added\": {}}]',12,1),(189,'2019-09-24 13:01:46.070774','46','九月二号',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(190,'2019-09-24 13:04:26.694008','50','TODOLIST',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(191,'2019-10-13 22:59:45.312028','61','单线程同步模型',1,'[{\"added\": {}}]',12,1),(192,'2019-10-13 23:00:33.256943','61','单线程同步模型',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(193,'2019-10-13 23:10:32.715217','61','RPC',2,'[{\"changed\": {\"fields\": [\"title\", \"body\"]}}]',12,1),(194,'2019-10-14 01:13:59.123794','61','RPC',2,'[{\"changed\": {\"fields\": [\"body\", \"views\"]}}]',12,1),(195,'2019-10-14 03:09:29.382007','61','RPC',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(196,'2019-10-14 03:19:30.201425','61','RPC',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(197,'2019-10-14 05:30:19.610639','61','RPC',2,'[{\"changed\": {\"fields\": [\"body\"]}}]',12,1),(198,'2019-10-17 03:24:01.767778','30','虚拟环境',1,'[{\"added\": {}}]',10,1),(199,'2019-10-17 03:24:05.008003','62','python pyenv虚拟环境',1,'[{\"added\": {}}]',12,1),(200,'2019-10-17 03:40:51.174844','62','python pyenv虚拟环境',2,'[{\"changed\": {\"fields\": [\"views\"]}}]',12,1),(201,'2019-10-21 20:35:43.518158','63','k8s 还没看完',1,'[{\"added\": {}}]',12,1);
/*!40000 ALTER TABLE `django_admin_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `django_content_type`
--

DROP TABLE IF EXISTS `django_content_type`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `django_content_type` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `app_label` varchar(100) NOT NULL,
  `model` varchar(100) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `django_content_type_app_label_model_76bd3d3b_uniq` (`app_label`,`model`)
) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `django_content_type`
--

LOCK TABLES `django_content_type` WRITE;
/*!40000 ALTER TABLE `django_content_type` DISABLE KEYS */;
INSERT INTO `django_content_type` VALUES (13,'accounts','bloguser'),(1,'admin','logentry'),(3,'auth','group'),(2,'auth','permission'),(12,'blog','article'),(7,'blog','blogsettings'),(11,'blog','category'),(8,'blog','links'),(9,'blog','sidebar'),(10,'blog','tag'),(14,'comments','comment'),(4,'contenttypes','contenttype'),(15,'oauth','oauthconfig'),(16,'oauth','oauthuser'),(19,'owntracks','owntracklog'),(17,'servermanager','commands'),(18,'servermanager','emailsendlog'),(5,'sessions','session'),(6,'sites','site');
/*!40000 ALTER TABLE `django_content_type` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `django_migrations`
--

DROP TABLE IF EXISTS `django_migrations`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `django_migrations` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `app` varchar(255) NOT NULL,
  `name` varchar(255) NOT NULL,
  `applied` datetime(6) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `django_migrations`
--

LOCK TABLES `django_migrations` WRITE;
/*!40000 ALTER TABLE `django_migrations` DISABLE KEYS */;
INSERT INTO `django_migrations` VALUES (1,'contenttypes','0001_initial','2019-08-13 03:28:23.844472'),(2,'contenttypes','0002_remove_content_type_name','2019-08-13 03:28:24.151201'),(3,'auth','0001_initial','2019-08-13 03:28:24.222934'),(4,'auth','0002_alter_permission_name_max_length','2019-08-13 03:28:24.432916'),(5,'auth','0003_alter_user_email_max_length','2019-08-13 03:28:24.441169'),(6,'auth','0004_alter_user_username_opts','2019-08-13 03:28:24.449053'),(7,'auth','0005_alter_user_last_login_null','2019-08-13 03:28:24.456526'),(8,'auth','0006_require_contenttypes_0002','2019-08-13 03:28:24.459293'),(9,'auth','0007_alter_validators_add_error_messages','2019-08-13 03:28:24.468068'),(10,'auth','0008_alter_user_username_max_length','2019-08-13 03:28:24.480657'),(11,'auth','0009_alter_user_last_name_max_length','2019-08-13 03:28:24.492432'),(12,'auth','0010_alter_group_name_max_length','2019-08-13 03:28:24.535433'),(13,'auth','0011_update_proxy_permissions','2019-08-13 03:28:24.544483'),(14,'accounts','0001_initial','2019-08-13 03:28:24.644957'),(15,'admin','0001_initial','2019-08-13 03:28:24.885274'),(16,'admin','0002_logentry_remove_auto_add','2019-08-13 03:28:24.973723'),(17,'admin','0003_logentry_add_action_flag_choices','2019-08-13 03:28:24.984462'),(18,'blog','0001_initial','2019-08-13 03:28:25.270035'),(19,'comments','0001_initial','2019-08-13 03:28:25.624540'),(20,'oauth','0001_initial','2019-08-13 03:28:25.876761'),(21,'owntracks','0001_initial','2019-08-13 03:28:25.960461'),(22,'servermanager','0001_initial','2019-08-13 03:28:26.018730'),(23,'sessions','0001_initial','2019-08-13 03:28:26.053887'),(24,'sites','0001_initial','2019-08-13 03:28:26.104711'),(25,'sites','0002_alter_domain_unique','2019-08-13 03:28:26.138352');
/*!40000 ALTER TABLE `django_migrations` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `django_session`
--

DROP TABLE IF EXISTS `django_session`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `django_session` (
  `session_key` varchar(40) NOT NULL,
  `session_data` longtext NOT NULL,
  `expire_date` datetime(6) NOT NULL,
  PRIMARY KEY (`session_key`),
  KEY `django_session_expire_date_a5c62663` (`expire_date`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `django_session`
--

LOCK TABLES `django_session` WRITE;
/*!40000 ALTER TABLE `django_session` DISABLE KEYS */;
INSERT INTO `django_session` VALUES ('17fkog0lz5o2it90z2pgem7abmlbppxy','NWVlODlmNzM1ZWJkMmZhZmNiNTg4YWFjNWU3ZDNmYjU2ZTM3ZGI4ZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiYWNjb3VudHMudXNlcl9sb2dpbl9iYWNrZW5kLkVtYWlsT3JVc2VybmFtZU1vZGVsQmFja2VuZCIsIl9hdXRoX3VzZXJfaGFzaCI6IjA1ZTdlNjc0MGM4OTRkYThhOTA4ZDNkYzA4ZWQ3ZDhmMDA2YTJhNWEifQ==','2019-10-27 22:58:05.934567'),('1z34xs1bjdedl3dw4na675boyw5zpn4w','NWVlODlmNzM1ZWJkMmZhZmNiNTg4YWFjNWU3ZDNmYjU2ZTM3ZGI4ZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiYWNjb3VudHMudXNlcl9sb2dpbl9iYWNrZW5kLkVtYWlsT3JVc2VybmFtZU1vZGVsQmFja2VuZCIsIl9hdXRoX3VzZXJfaGFzaCI6IjA1ZTdlNjc0MGM4OTRkYThhOTA4ZDNkYzA4ZWQ3ZDhmMDA2YTJhNWEifQ==','2019-09-11 12:02:11.210802'),('4hg2u1xmwyddzbejso5zls5xo49by0pd','NWVlODlmNzM1ZWJkMmZhZmNiNTg4YWFjNWU3ZDNmYjU2ZTM3ZGI4ZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiYWNjb3VudHMudXNlcl9sb2dpbl9iYWNrZW5kLkVtYWlsT3JVc2VybmFtZU1vZGVsQmFja2VuZCIsIl9hdXRoX3VzZXJfaGFzaCI6IjA1ZTdlNjc0MGM4OTRkYThhOTA4ZDNkYzA4ZWQ3ZDhmMDA2YTJhNWEifQ==','2019-08-27 03:40:46.144069'),('pj5t1k431vch072u2gzohsa5u60jn139','NWVlODlmNzM1ZWJkMmZhZmNiNTg4YWFjNWU3ZDNmYjU2ZTM3ZGI4ZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiYWNjb3VudHMudXNlcl9sb2dpbl9iYWNrZW5kLkVtYWlsT3JVc2VybmFtZU1vZGVsQmFja2VuZCIsIl9hdXRoX3VzZXJfaGFzaCI6IjA1ZTdlNjc0MGM4OTRkYThhOTA4ZDNkYzA4ZWQ3ZDhmMDA2YTJhNWEifQ==','2019-10-08 11:41:26.518464'),('rb8hv5814niuvbrml82z2rai8ssg50lc','NWVlODlmNzM1ZWJkMmZhZmNiNTg4YWFjNWU3ZDNmYjU2ZTM3ZGI4ZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiYWNjb3VudHMudXNlcl9sb2dpbl9iYWNrZW5kLkVtYWlsT3JVc2VybmFtZU1vZGVsQmFja2VuZCIsIl9hdXRoX3VzZXJfaGFzaCI6IjA1ZTdlNjc0MGM4OTRkYThhOTA4ZDNkYzA4ZWQ3ZDhmMDA2YTJhNWEifQ==','2019-10-10 02:00:29.623792'),('vfhmbsfs5qv7kc02w36m0h46j9m1jsd0','NWVlODlmNzM1ZWJkMmZhZmNiNTg4YWFjNWU3ZDNmYjU2ZTM3ZGI4ZTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiYWNjb3VudHMudXNlcl9sb2dpbl9iYWNrZW5kLkVtYWlsT3JVc2VybmFtZU1vZGVsQmFja2VuZCIsIl9hdXRoX3VzZXJfaGFzaCI6IjA1ZTdlNjc0MGM4OTRkYThhOTA4ZDNkYzA4ZWQ3ZDhmMDA2YTJhNWEifQ==','2019-09-07 11:34:11.604922');
/*!40000 ALTER TABLE `django_session` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `django_site`
--

DROP TABLE IF EXISTS `django_site`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `django_site` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `domain` varchar(100) NOT NULL,
  `name` varchar(50) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `django_site_domain_a2e37b91_uniq` (`domain`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `django_site`
--

LOCK TABLES `django_site` WRITE;
/*!40000 ALTER TABLE `django_site` DISABLE KEYS */;
INSERT INTO `django_site` VALUES (1,'sundazhong.com','sundazhong.com');
/*!40000 ALTER TABLE `django_site` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `oauth_oauthconfig`
--

DROP TABLE IF EXISTS `oauth_oauthconfig`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `oauth_oauthconfig` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `type` varchar(10) NOT NULL,
  `appkey` varchar(200) NOT NULL,
  `appsecret` varchar(200) NOT NULL,
  `callback_url` varchar(200) NOT NULL,
  `is_enable` tinyint(1) NOT NULL,
  `created_time` datetime(6) NOT NULL,
  `last_mod_time` datetime(6) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `oauth_oauthconfig`
--

LOCK TABLES `oauth_oauthconfig` WRITE;
/*!40000 ALTER TABLE `oauth_oauthconfig` DISABLE KEYS */;
/*!40000 ALTER TABLE `oauth_oauthconfig` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `oauth_oauthuser`
--

DROP TABLE IF EXISTS `oauth_oauthuser`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `oauth_oauthuser` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `openid` varchar(50) NOT NULL,
  `nikename` varchar(50) NOT NULL,
  `token` varchar(150) DEFAULT NULL,
  `picture` varchar(350) DEFAULT NULL,
  `type` varchar(50) NOT NULL,
  `email` varchar(50) DEFAULT NULL,
  `matedata` varchar(3000) DEFAULT NULL,
  `created_time` datetime(6) NOT NULL,
  `last_mod_time` datetime(6) NOT NULL,
  `author_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `oauth_oauthuser_author_id_a975bef0_fk_accounts_bloguser_id` (`author_id`),
  CONSTRAINT `oauth_oauthuser_author_id_a975bef0_fk_accounts_bloguser_id` FOREIGN KEY (`author_id`) REFERENCES `accounts_bloguser` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `oauth_oauthuser`
--

LOCK TABLES `oauth_oauthuser` WRITE;
/*!40000 ALTER TABLE `oauth_oauthuser` DISABLE KEYS */;
/*!40000 ALTER TABLE `oauth_oauthuser` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `owntracks_owntracklog`
--

DROP TABLE IF EXISTS `owntracks_owntracklog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `owntracks_owntracklog` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `tid` varchar(100) NOT NULL,
  `lat` double NOT NULL,
  `lon` double NOT NULL,
  `created_time` datetime(6) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `owntracks_owntracklog`
--

LOCK TABLES `owntracks_owntracklog` WRITE;
/*!40000 ALTER TABLE `owntracks_owntracklog` DISABLE KEYS */;
/*!40000 ALTER TABLE `owntracks_owntracklog` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `servermanager_commands`
--

DROP TABLE IF EXISTS `servermanager_commands`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `servermanager_commands` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(300) NOT NULL,
  `command` varchar(2000) NOT NULL,
  `describe` varchar(300) NOT NULL,
  `created_time` datetime(6) NOT NULL,
  `last_mod_time` datetime(6) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `servermanager_commands`
--

LOCK TABLES `servermanager_commands` WRITE;
/*!40000 ALTER TABLE `servermanager_commands` DISABLE KEYS */;
/*!40000 ALTER TABLE `servermanager_commands` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `servermanager_emailsendlog`
--

DROP TABLE IF EXISTS `servermanager_emailsendlog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `servermanager_emailsendlog` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `emailto` varchar(300) NOT NULL,
  `title` varchar(2000) NOT NULL,
  `content` longtext NOT NULL,
  `send_result` tinyint(1) NOT NULL,
  `created_time` datetime(6) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `servermanager_emailsendlog`
--

LOCK TABLES `servermanager_emailsendlog` WRITE;
/*!40000 ALTER TABLE `servermanager_emailsendlog` DISABLE KEYS */;
INSERT INTO `servermanager_emailsendlog` VALUES (1,'252301699@qq.com','感谢您发表的评论','\n                   <p>非常感谢您在本站发表评论</p>\n                   您可以访问\n                   <a href=\"https://example.com/article/2019/8/13/1.html\" rel=\"bookmark\">Hello world</a>\n                   来查看您的评论，\n                   再次感谢您！\n                   <br />\n                   如果上面链接无法打开，请将此链接复制至浏览器。\n                   https://example.com/article/2019/8/13/1.html\n                   ',0,'2019-08-13 06:26:02.272114'),(2,'1203707239@qq.com','验证您的电子邮箱','\n                            <p>请点击下面链接验证您的邮箱</p>\n    \n                            <a href=\"http://sundazhong.com/account/result.html?type=validation&id=3&sign=9efb2fa8a1d12a40da5a5ac6d2dc98ba\" rel=\"bookmark\">http://sundazhong.com/account/result.html?type=validation&id=3&sign=9efb2fa8a1d12a40da5a5ac6d2dc98ba</a>\n    \n                            再次感谢您！\n                            <br />\n                            如果上面链接无法打开，请将此链接复制至浏览器。\n                            http://sundazhong.com/account/result.html?type=validation&id=3&sign=9efb2fa8a1d12a40da5a5ac6d2dc98ba\n                            ',0,'2019-09-24 01:29:08.820251'),(3,'252301699@qq.com','感谢您发表的评论','\n                   <p>非常感谢您在本站发表评论</p>\n                   您可以访问\n                   <a href=\"https://sundazhong.com/article/2019/9/4/50.html\" rel=\"bookmark\">TODOLIST</a>\n                   来查看您的评论，\n                   再次感谢您！\n                   <br />\n                   如果上面链接无法打开，请将此链接复制至浏览器。\n                   https://sundazhong.com/article/2019/9/4/50.html\n                   ',0,'2019-09-26 02:00:36.528745');
/*!40000 ALTER TABLE `servermanager_emailsendlog` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2019-11-17 17:01:59
